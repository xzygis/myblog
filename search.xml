<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tair:分布式键/值存储系统</title>
    <url>/2022/11/27/Tair-A-distributed-key-value-storage-system-developed-by-Alibaba-Group/</url>
    <content><![CDATA[<h1 id="产品概览"><a href="#产品概览" class="headerlink" title="产品概览"></a>产品概览</h1><p>Tair 是快速访问内存 (MDB)/持久性 (LDB) 存储服务。</p>
<p>Tair采用高性能、高可用的分布式集群架构，可以满足企业对读写性能和可扩展容量的高要求。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>Tair 集群具有三个必要的模块：ConfigServer、DataServer 和客户端。</p>
<a id="more"></a>

<p><img src="tair_structure.jpg" alt="Architecture"></p>
<p>通常，一个 Tair 集群包括两个 ConfigServer 和多个 DataServer。 两个 ConfigServer 充当主服务器和备用服务器。 DataServer 和 ConfigServer 之间的心跳检查用于检查集群中活跃的和可用的 DataServer，以建立集群中数据的分布（比较表）。 DataServers 按照 ConfigServer 的指示存储、复制和迁移数据。当客户端启动时，它从 ConfigServer 获取数据分布信息。客户端根据这些数据分布信息，与对应的DataServer进行交互，执行用户的请求。</p>
<p>在架构上，ConfigServer 的作用类似于传统应用系统中的中心节点。整个集群服务依赖于ConfigServer。 事实上，Tair 的 ConfigServers 是非常轻量级的。当一个工作的 ConfigServer 遇到停机时间时，另一个 ConfigServer 会在几秒钟内自动接管。 即使两个 ConfigServer 同时停机，只要 DataServer 没有变化，Tair 也可以正常运行。 用户只需要将应用程序连接到 ConfigServers，不需要知道内部节点的详细信息。</p>
<h2 id="ConfigServer"><a href="#ConfigServer" class="headerlink" title="ConfigServer"></a>ConfigServer</h2><p>两个 ConfigServers 作为主服务器和备用服务器。</p>
<p>集群的实时和可用 DataServer 节点信息是使用 ConfigServer 和 DataServer 之间的心跳检查确定的。</p>
<p>ConfigServer根据DataServer节点信息构建数据分布表，展示数据在集群中的分布情况。</p>
<p>ConfigServer 提供数据分发表查询服务。</p>
<p>ConfigServer 调度数据服务器之间的数据迁移和复制。</p>
<h2 id="DataServers-数据服务器"><a href="#DataServers-数据服务器" class="headerlink" title="DataServers 数据服务器"></a>DataServers 数据服务器</h2><p>DataServers 提供存储引擎。</p>
<p>DataServers 接收客户端发起的操作，例如 put/get/remove。</p>
<p>DataServers 迁移和复制数据。</p>
<p>DataServers 提供访问统计信息。</p>
<h2 id="Clients-客户端"><a href="#Clients-客户端" class="headerlink" title="Clients 客户端"></a>Clients 客户端</h2><p>客户端提供用于访问 Tair 集群的 API。</p>
<p>客户端更新和缓存数据分发表。</p>
<p>客户端提供LocalCache，防止过热的数据访问影响Tair集群服务。</p>
<p>客户端控制流量。</p>
<h1 id="产品特点"><a href="#产品特点" class="headerlink" title="产品特点"></a>产品特点</h1><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p>分布式集群架构用于提供自动灾难恢复和故障转移。</p>
<p>支持负载均衡，数据分布均匀。</p>
<p>系统存储空间和吞吐量性能可以弹性伸缩，解决数据量和QPS性能限制。</p>
<p>功能齐全且用户友好的访问</p>
<p>数据结构丰富。 支持单级键值结构和二级索引结构。</p>
<p>支持各种用途。 还支持计数器模式。</p>
<p>支持数据过期和版本控制。</p>
<h2 id="Version-支持"><a href="#Version-支持" class="headerlink" title="Version 支持"></a>Version 支持</h2><p>Tair 中的每个数据都包含版本号，版本号在每次更新后都会递增。这个特性有助于防止由于数据的并发更新导致的问题。</p>
<p>比如，系统有一个 value 为 “a,b,c”，A 和 B 同时 get 到这个 value。A 执行操作，在后面添加一个 d，value 为 “a,b,c,d”。B 执行操作添加一个 e，value 为”a,b,c,e”。如果不加控制，无论 A 和 B 谁先更新成功，它的更新都会被后到的更新覆盖。</p>
<p>Tair 无法解决这个问题，但是引入了 version 机制避免这样的问题。还是拿刚才的例子，A 和 B 取到数据，假设版本号为 10，A 先更新，更新成功后，value 为”a,b,c,d”，与此同时，版本号会变为 11。当 B 更新时，由于其基于的版本号是 10，服务器会拒绝更新，从而避免 A 的更新被覆盖。B 可以选择 get 新版本的 value，然后在其基础上修改，也可以选择强行更新。</p>
<h2 id="Item-支持"><a href="#Item-支持" class="headerlink" title="Item 支持"></a>Item 支持</h2><p>Tair 还支持将 value 视为一个 item 数组，对 value 中的部分 item 进行操作。比如有个 key 的 value 为 [1,2,3,4,5]，我们可以只获取前两个 item，返回 [1,2]，也可以删除第一个 item，还支持将数据删除，并返回被删除的数据，通过这个接口可以实现一个原子的分布式 FIFO 的队列。</p>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><h2 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h2><p>随着业务量的增加，对数据库系统的并发请求越来越多，数据库系统的负载越来越重。当数据库系统过载时，响应速度会变慢，在极端情况下甚至会导致服务中断。</p>
<p>为了解决这个问题，Tair MDB 可以与数据库产品一起部署，以提供高吞吐量和低延迟的存储。</p>
<p>MDB 响应速度快，一般毫秒级完成请求。而且，MDB 支持更高的 QPS 速率，可以处理比数据库更多的并发请求。</p>
<p>通过观察业务，用户可以将热点数据存储在MDB中，显着减轻数据库的负载。这不仅降低了数据库成本，还提高了系统可用性。</p>
<h2 id="临时数据存储"><a href="#临时数据存储" class="headerlink" title="临时数据存储"></a>临时数据存储</h2><p>社交网站、电商网站、游戏、广告等应用需要维护大量的临时数据。</p>
<p>在 MDB 中存储临时数据可以减少内存管理开销和应用程序负载。在分布式环境中，MDB可以作为统一的全局存储，可以防止单点故障造成的数据丢失，解决多个应用之间同步的问题。</p>
<p>一个常见的例子是使用 MDB 作为会话管理器。如果网站采用分布式部署，并且流量很大，同一用户的不同请求可能会发送到不同的Web服务器。</p>
<p>在这种情况下，MDB 可以作为全局存储解决方案来保存会话数据、用户令牌、权限信息等数据。</p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>推荐和广告业务通常需要离线计算大量数据。 LDB 支持持久存储并提供卓越的性能。</p>
<p>支持在线服务，允许用户定期将离线数据导入LDB进行在线服务。</p>
<p>经过计算，列表业务可以将最终列表存储在LDB中，直接展示给前端应用程序。</p>
<p>这样，LDB 就满足了存储和高速访问的需求。</p>
<h2 id="黑名单-白名单"><a href="#黑名单-白名单" class="headerlink" title="黑名单/白名单"></a>黑名单/白名单</h2><p>安全应用程序有许多黑名单/白名单方案。这些黑名单/白名单场景的特点是命中率低、访问量大、数据丢失导致业务损失。</p>
<p>LDB 支持数据持久化和高访问量，因此在这些场景中被广泛使用。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁通常用于防止多线程并发导致的数据不一致和逻辑混乱。分布式锁可以使用 Tair 的版本特性或计算功能来实现。</p>
<p>得益于LBS的持久化，即使服务宕机，锁也不会丢失，可以正常释放。</p>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>--cache</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员做需求时容易忽视的若干问题</title>
    <url>/2022/11/20/Some-problems-that-programmers-tend-to-ignore-when-making-requirements/</url>
    <content><![CDATA[<p>程序员大部分时间都在承接一个个的需求，在做需求的过程中，有一些问题是我们容易忽视的，究其原因，主要是在做需求的过程中缺少思考，或者思考不够全面。而思考的缺失，正是导致部分人所说的“做业务需求没有成长”的主要原因之一。今天主要从研发流程中重要的几个阶段出发，跟大家谈谈做需求的过程中有哪些是我们容易忽视的问题。</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>PM是我们的需求的最主要来源，在需求分析阶段，需要避免的问题是：一、没有理解清楚需求细节，而直接进入后续的方案设计和开发阶段；二、需求里说怎么干，我们就怎么干。<br>问题一容易造成的结果是，功能开发上线完成了，结果发现不是PM想要的，导致不必要的返工成本。另外，由于没有真正理清需求，也有可能导致项目的整体架构设计产生重大偏差，从而给后续的架构迭代留下隐患。<br>问题二容易造成的结果是，PM想做的功能点都做好了，却只是解决了一个本就不存在的问题，导致人力的浪费。特斯拉进行生产线自动化的时候，有一个零件的自动化安装总是出问题，特斯拉的工程师为了优化这个自动化流程，投入了大量的资金和精力。 后来马斯克问他们的技术人员，为什么需要这个零件，结果发现大家居然并不清楚。最后证明其实在电动车上，根本不需要这个零件。<br>为了避免以上两个问题，当我们接到PM需求时，应该详细地了解需求的功能细节，以及这个需求需要解决的问题是什么，最终是服务于什么目的，是否有助于达成业务的总体目标。以电商行业为例，我们应该思考所做的需求是否有助于提升商品的导购和流通效率，是否能帮卖家多挣钱，是否能帮买家更快找到想要的商品，是否能帮助平台提升竞争力。</p>
<a id="more"></a>

<h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><p>在方案设计阶段，需要避免的问题是：“这个需求很简单，不用走方案设计和评审环节了，我直接开发吧，很快就可以上线了”。有些需求可能只是简单的修改一两个接口，或者只是对现有的流程做部分调整，这往往容易让我们过于自信，认为直接开干也不会有问题。其实，在我们真正理清楚方案之前，它并不简单，而确保我们真正理清方案的方式，就是按照部门的方案设计模板，把技术方案写出来，对照CheckList，逐一完成各个检查项。<br>所谓磨刀不误砍柴工，在方案设计阶段多花一些时间，可以帮助我们建设出更加合理的系统架构，让我们在技术架构上不断积累资产，资产的不断增值会让我们在能力建设和研发效率等方面长期受益。相反，如果我们忽视了方案设计，则会不断地积累技术债，后续需要投入很多精力去还债。</p>
<h1 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h1><p>在代码开发方面，需要避免的问题是：“对工程质量要求低，认为能实现功能就行”。实际上，代码也是一种语言，它不仅用于人与机器之间的交流，而且也用于人与人之间的交流。逻辑复杂、晦涩难懂的代码可能会导致以下问题：一、隐藏bug，而且往往很不好改；二、后续有功能迭代时，逻辑修改非常复杂。<br>逻辑的正确性，是我们编码时的最低要求，编码时应该尽可能的追求信、达、雅。在编码方面主要给两点建议：一、遵守公司和部门的研发规范，包括分支规范、代码规范等；二、写代码时要多思考自己的写法是不是最优的，还有没有更好的写法。</p>
<h1 id="服务上线"><a href="#服务上线" class="headerlink" title="服务上线"></a>服务上线</h1><p>在服务上线阶段，需要避免的是观察不细致，想当然的认为没问题，结果到最后导致了一个大问题。在上线阶段，我们应该加强检查，从多角度对服务进行观察，包括：上游角度、服务本身角度、下游角度，观察的指标，既包括错误率、时延、错误日志等通用指标，也包括业务自定义指标（应该在方案设计阶段考虑清楚后续有什么手段可以观测服务是否正常）。<br>值得一提的是，服务上线完成并不是结束，而是一个新的开始。我们需要采取各种手段保障服务的稳定运行，并不断发现其中的可优化点，推动服务SLI稳步提升。</p>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>--advice</tag>
      </tags>
  </entry>
  <entry>
    <title>给新人程序员的职场建议</title>
    <url>/2022/11/20/Career-Advice-for-Beginning-Programmers/</url>
    <content><![CDATA[<p>我是一位在大厂打拼多年的程序员，今天想结合自己的工作经历给新人程序员们提出若干建议，希望能够在一定程度上帮助大家在职场脱颖而出。</p>
<h1 id="积极主动"><a href="#积极主动" class="headerlink" title="积极主动"></a>积极主动</h1><p>第一个建议是要积极主动，有owner意识，勇于承担工作职责，并在工作中做出成绩。<br>首先，领取任务或接受任务应该积极主动。在工作中可以主动向领导提出来自己对什么方向的项目感兴趣，希望承担什么样的任务。当领导知道你是积极主动的人，而且也发现你确实有能力胜任某项工作时，就会优先想到你。在领导主动布置工作任务时，也不应该过多的考虑这项工作好不好干、难度怎么样，而是应该要积极主动的接受。<br>其次，在执行任务的过程中，应该发挥主观能动性，从而使成果达到预期或尽可能的超出预期。这就要求我们理清任务的本质，思考任务背后的更深层次的逻辑，从而确定目标、理清思路、拆解任务、贯彻执行。这里特别需要避免的是，简单地成为“任务执行器”，即机械的执行任务，而不知道做完这个任务之后能解决什么问题，后续又还需要做什么。</p>
<a id="more"></a>

<h1 id="善于沟通"><a href="#善于沟通" class="headerlink" title="善于沟通"></a>善于沟通</h1><p>作为研发，工作中不免要和很多同事进行沟通，比如跟PM对接需求、跟其他前后端RD聊技术方案、跟QA聊测试用例等，因此高效的沟通可以在很大程度上提升我们的工作效率。在善于沟通方面，主要的建议是：一、不要与人争吵；二、换位思考。<br>争吵不能解决任何的问题，反而容易让人丧失理智，而且容易影响自己在旁观者心里的印象。换位思考是解决沟通问题的利器，先谈对方最关心的点，让对方感受到你的真诚。遇到分歧时，先找共同点，求同存异，往往事半功倍。</p>
<h1 id="保持好奇心"><a href="#保持好奇心" class="headerlink" title="保持好奇心"></a>保持好奇心</h1><p>软件研发方面的技术日新月异，不断有新的编程语言、存储组件、技术框架等出现，为了保持保持和增加自己的核心竞争力，对于工作中用到的相关组件和框架，应该不断去挖掘背后的底层原理。比如说工作中用到了HTTP协议，那么就应该思考：为什么会有HTTP？它的演进过程是怎样的？有什么设计理念是值得我们学习的？它还有什么缺陷是需要改进的吗？<br>除了熟悉工作中用到的技术组件的原理之外，也应该多关注一些前沿的技术趋势，了解业界同行的一些优秀的实践经验，可能的方式包括关注InfoQ、美团技术博客等公众号发布的高质量文档。<br>这里特别需要避免的是，整天抱怨自己的工作只是CRUD，认为自己的工作没价值，但是却不愿去发掘自己的工作背后的有价值的东西。</p>
<h1 id="引人注目"><a href="#引人注目" class="headerlink" title="引人注目"></a>引人注目</h1><p>程序员是技术性很强的工作，技术是我们的立身之本，但我们也要避免只会研究技术、埋头苦干。对于交到我们手里的工作，我们要尽可能地做好，同时也需要积极地向领导汇报进展和成果，这样领导才会知道事情的进度是可控的、成果是可预期的，对于你个人的工作产出也自然心里有数了。<br>在引人注目方面，另外很重要的一点是：发表文章。如果只有你自己知道你是绝顶高手，是没有意义的，你需要通过发表文章的方式表述所学所思所想，让其他人知道你的实力，从而扩大你的影响力。</p>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>--advice</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Bloom Filter基本原理及使用方式</title>
    <url>/2021/06/12/introduction-to-the-basic-principles-of-Bloom-Filter/</url>
    <content><![CDATA[<p>一提到元素查找，我们会很自然的想到<code>HashMap</code>。通过将哈希函数作用于key上，我们得到了哈希值，基于哈希值我们可以去表里的相应位置获取对应的数据。除了存在哈希冲突问题之外，<code>HashMap</code>一个很大的问题就是空间效率低。引入<code>Bloom Filter</code>则可以很好的解决空间效率的问题。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Bloom Filter是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对bit-map 的扩展，布隆过滤器被设计为一个具有N的元素的位数组A（bit array），初始时所有的位都置为0。</p>
<p>当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了。</p>
<ul>
<li>如果这些点有任何一个 0，则被检索元素一定不在；</li>
<li>如果都是 1，则被检索元素很可能在。</li>
</ul>
<a id="more"></a>

<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>要添加一个元素，我们需要提供k个哈希函数。每个函数都能返回一个值，这个值必须能够作为位数组的索引（可以通过对数组长度进行取模得到）。然后，我们把位数组在这个索引处的值设为1。例如，第一个哈希函数作用于元素I上，返回x。类似的，第二个第三个哈希函数返回y与z，那么：<br><code>A[x]=A[y]=A[z] = 1</code></p>
<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>查找的过程与上面的过程类似，元素将会被会被不同的哈希函数处理三次，每个哈希函数都返回一个作为位数组索引值的整数，然后我们检测位数组在x、y与z处的值是否为1。如果有一处不为1，那么就说明这个元素没有被添加到这个布隆过滤器中。如果都为1，就说明这个元素在布隆过滤器里面。当然，会有一定误判的概率。</p>
<h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p>通过上面的解释我们可以知道，如果想设计出一个好的布隆过滤器，我们必须遵循以下准则：</p>
<ul>
<li>好的哈希函数能够尽可能的返回宽范围的哈希值。</li>
<li>位数组的大小（用m表示）非常重要：如果太小，那么所有的位很快就都会被赋值为1，这样就增加了误判的几率。</li>
<li>哈希函数的个数（用k表示）对索引值的均匀分配也很重要。</li>
</ul>
<p>计算m的公式如下：<br><code>m = - nlog p / (log2)^2</code><br>这里p为可接受的误判率。</p>
<p>计算k的公式如下：<br><code>k = m/n log(2)</code><br>这里k=哈希函数个数，m=位数组个数，n=待检测元素的个数（后面会用到这几个字母）。</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法是影响布隆过滤器性能的地方。我们需要选择一个效率高但不耗时的哈希函数，在论文《更少的哈希函数，相同的性能指标：构造一个更好的布隆过滤器》中，讨论了如何选用2个哈希函数来模拟k个哈希函数。首先，我们需要计算两个哈希函数h1(x)与h2(x)。然后，我们可以用这两个哈希函数来模仿产生k个哈希函数的效果：<br><code>gi(x) = h1(x) + ih2(x)</code><br>这里i的取值范围是1到k的整数。</p>
<p>Google Guava类库使用这个技巧实现了一个布隆过滤器，哈希算法的主要逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> hash64 = ...;</span><br><span class="line"><span class="keyword">int</span> hash1 = (<span class="keyword">int</span>) hash64;</span><br><span class="line"><span class="keyword">int</span> hash2 = (<span class="keyword">int</span>) (hash64 &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numHashFunctions; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">  <span class="comment">// Flip all the bits if it's negative (guaranteed positive number)</span></span><br><span class="line">  <span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    combinedHash = ~combinedHash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Guava中的Bloom Filter使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> expectedInsertions = ...; <span class="comment">//待检测元素的个数</span></span><br><span class="line"><span class="keyword">double</span> fpp = <span class="number">0.03</span>; <span class="comment">//误判率(desired false positive probability)</span></span><br><span class="line">BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"UTF-8"</span>)), expectedInsertions,fpp);</span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>它的优点是空间效率和查询时间都远远超过一般的算法，布隆过滤器存储空间和插入/查询时间都是常数O(k)。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>布隆过滤器的缺点和优点一样明显，误算率是其中之一。</p>
<p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面，而这一点单凭这个过滤器是无法保证的。</p>
<p>参考来源：</p>
<ul>
<li><a href="https://www.javacodegeeks.com/2014/07/how-to-use-bloom-filter-to-build-a-large-in-memory-cache-in-java.html" target="_blank" rel="noopener">https://www.javacodegeeks.com/2014/07/how-to-use-bloom-filter-to-build-a-large-in-memory-cache-in-java.html</a></li>
<li><a href="https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html" target="_blank" rel="noopener">https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html</a></li>
<li><a href="https://segmentfault.com/a/1190000002729689" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002729689</a></li>
</ul>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>bloom filter</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件传输的三种方式</title>
    <url>/2021/06/12/Three-ways-to-transfer-files-in-Linux/</url>
    <content><![CDATA[<h1 id="1-nc命令"><a href="#1-nc命令" class="headerlink" title="1 nc命令"></a>1 nc命令</h1><p>执行如下命令，在目标机器(假设ip为<code>10.11.12.13</code>)上监听端口<code>8415</code></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">nc</span> -l <span class="number">8415</span> &gt; <span class="class"><span class="keyword">data</span>.txt</span></span><br></pre></td></tr></table></figure>

<p>往目标机器发送数据 </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nc -v <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span> <span class="number">8415</span> &lt; ~/Downloads/data.txt</span><br></pre></td></tr></table></figure>

<h1 id="2-SimpleHTTPServer"><a href="#2-SimpleHTTPServer" class="headerlink" title="2 SimpleHTTPServer"></a>2 SimpleHTTPServer</h1><p>在服务器(假设ip为<code>10.11.12.13</code>)上执行如下命令: </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer <span class="number">8411</span></span><br></pre></td></tr></table></figure>
<p>然后在本地机器打开浏览器，输入<code>http://10.11.12.13:8411/</code>可以访问。</p>
<h1 id="3-scp命令"><a href="#3-scp命令" class="headerlink" title="3 scp命令"></a>3 scp命令</h1><p>Linux scp命令用于Linux之间复制文件和目录。</p>
<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>
<p>在目标机器执行如下命令： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">scp -l <span class="number">700000</span> username<span class="meta">@dev</span>.test.<span class="string">com:</span><span class="regexp">~/data.txt ./</span></span><br></pre></td></tr></table></figure>
<p>即可把目标机器dev.test.com的文件~/data.txt拷贝到当前目录。</p>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Websocket介绍</title>
    <url>/2021/06/12/introduction-of-websocket/</url>
    <content><![CDATA[<h1 id="什么是WebSocket？"><a href="#什么是WebSocket？" class="headerlink" title="什么是WebSocket？"></a>什么是WebSocket？</h1><p>WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层。WebSocket协议在2011年由IETF标准化为RFC 6455，后由RFC 7936补充规范。</p>
<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p>
<h2 id="有哪些优点？"><a href="#有哪些优点？" class="headerlink" title="有哪些优点？"></a>有哪些优点？</h2><ol>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li>
<li>强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
</ol>
<a id="more"></a>

<h1 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h1><p>WebSocket是一种与HTTP不同的协议。两者都位于OSI模型的应用层，并且都依赖于传输层的TCP协议。 虽然它们不同，但是RFC 6455中规定：it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头从HTTP协议更改为WebSocket协议。</p>
<h2 id="握手例子"><a href="#握手例子" class="headerlink" title="握手例子"></a>握手例子</h2><p>一个典型的Websocket握手请求如下：</p>
<p>客户端请求：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure>

<p>服务器回应：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>


<h2 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h2><ul>
<li>Connection必须设置Upgrade，表示客户端希望连接升级。</li>
<li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li>
<li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行Base64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li>
<li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li>
<li>Origin字段是必须的。如果缺少origin字段，WebSocket服务器需要回复HTTP 403 状态码（禁止访问）。</li>
</ul>
<h2 id="体验一下"><a href="#体验一下" class="headerlink" title="体验一下"></a>体验一下</h2><blockquote>
<p><a href="https://www.websocket.org/echo.html" target="_blank" rel="noopener">https://www.websocket.org/echo.html</a></p>
</blockquote>
<p><img src="websocket.org-1.png" alt="Connect"></p>
<p>握手报文：</p>
<p><img src="websocket.org-2.png" alt="握手报文"></p>
<p>数据传输：</p>
<p><img src="websocket.org-3.png" alt="握手报文"></p>
<h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p>
<ul>
<li>发送端：将消息切割成多个帧，并发送给服务端；</li>
<li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；</li>
</ul>
<h2 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h2><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|<span class="string">F</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string"> opcode</span>|<span class="string">M</span>|<span class="string"> Payload len </span>|<span class="string">    Extended payload length    </span>|</span><br><span class="line">|<span class="string">I</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">  (4)  </span>|<span class="string">A</span>|<span class="string">     (7)     </span>|<span class="string">             (16/64)           </span>|</span><br><span class="line">|<span class="string">N</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">       </span>|<span class="string">S</span>|<span class="string">             </span>|<span class="string">   (if payload len==126/127)   </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|<span class="string">       </span>|<span class="string">K</span>|<span class="string">             </span>|<span class="string">                               </span>|</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|<span class="string">     Extended payload length continued, if payload len == 127  </span>|</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|<span class="string">                               </span>|<span class="string">Masking-key, if MASK set to 1  </span>|</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">|<span class="string"> Masking-key (continued)       </span>|<span class="string">          Payload Data         </span>|</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|<span class="string">                     Payload Data continued ...                </span>|</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="字段说明-1"><a href="#字段说明-1" class="headerlink" title="字段说明"></a>字段说明</h2><p>FIN：1个比特。<br>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>
<p>RSV1, RSV2, RSV3：各占1个比特。<br>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>
<p>Opcode: 4个比特。<br>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>
<ul>
<li>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li>
<li>%x1：表示这是一个文本帧（frame）</li>
<li>%x2：表示这是一个二进制帧（frame）</li>
<li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li>
<li>%x8：表示连接断开。</li>
<li>%x9：表示这是一个ping操作。</li>
<li>%xA：表示这是一个pong操作。</li>
<li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li>
</ul>
<p>Mask: 1个比特。<br>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。<br>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。<br>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。<br>掩码的算法、用途在下一小节讲解。</p>
<p>Payload length：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。<br>假设数Payload length === x，如果</p>
<ul>
<li>x为0~126：数据的长度为x字节。</li>
<li>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。</li>
<li>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。</li>
</ul>
<p>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>
<p>Masking-key：0或4字节（32位）<br>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。<br>备注：载荷数据的长度，不包括mask key的长度。</p>
<p>Payload data：(x+y) 字节</p>
<ul>
<li>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</li>
<li>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</li>
<li>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</li>
</ul>
<h2 id="掩码算法"><a href="#掩码算法" class="headerlink" title="掩码算法"></a>掩码算法</h2><p>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法： </p>
<p>首先，预设：</p>
<ul>
<li>original-octet-i：为原始数据的第i字节。</li>
<li>transformed-octet-i：为转换后的数据的第i字节。</li>
<li>j：为i mod 4的结果。</li>
<li>masking-key-octet-j：为mask key第j字节。</li>
</ul>
<p>流程为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>
<p>伪代码大概是：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">var DECODED = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; ENCODED.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    DECODED[<span class="built_in">i</span>] = ENCODED[<span class="built_in">i</span>] ^ MASK[<span class="built_in">i</span> <span class="comment">% 4];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据掩码的作用：<br>WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。<br>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益（这也是不少同学疑惑的点）。<br>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>
<h1 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h1><p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。<br>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>
<h2 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h2><p>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。<br>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。<br>此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>
<h2 id="数据分片例子"><a href="#数据分片例子" class="headerlink" title="数据分片例子"></a>数据分片例子</h2><p>下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>
<p><em>第一条消息</em></p>
<p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>
<p><em>第二条消息</em></p>
<ol>
<li>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。</li>
<li>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。</li>
<li>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Client: <span class="attribute">FIN</span>=1, <span class="attribute">opcode</span>=0x1, <span class="attribute">msg</span>=<span class="string">"hello"</span></span><br><span class="line">Server: (process complete message immediately) Hi.</span><br><span class="line">Client: <span class="attribute">FIN</span>=0, <span class="attribute">opcode</span>=0x1, <span class="attribute">msg</span>=<span class="string">"and a"</span></span><br><span class="line">Server: (listening, new message containing text started)</span><br><span class="line">Client: <span class="attribute">FIN</span>=0, <span class="attribute">opcode</span>=0x0, <span class="attribute">msg</span>=<span class="string">"happy new"</span></span><br><span class="line">Server: (listening, payload concatenated <span class="keyword">to</span> previous message)</span><br><span class="line">Client: <span class="attribute">FIN</span>=1, <span class="attribute">opcode</span>=0x0, <span class="attribute">msg</span>=<span class="string">"year!"</span></span><br><span class="line">Server: (process complete message) Happy new year <span class="keyword">to</span> you too!</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h1><p>WebSocket 为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的 TCP 通道保持连接没有断开。<br>对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<ul>
<li>发送方 -&gt; 接收方：ping</li>
<li>接收方 -&gt; 发送方：pong</li>
</ul>
<p>ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode分别是0x9、0xA。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>WebSocket协议中规定在连接建立时检查Upgrade请求中的某些字段（如Origin，查看每次请求是否一致），对于不符合要求的请求立即断开，在通信过程中，也对Frame中的控制位做了很多限制，以便禁止异常连接。<br>websocket协议中也规定了数据加密传输的方式，允许使用TLS/SSL来对通信加密，默认ws的端口为80，wss端口为433，类似HTTP与HTTPS。</p>
<h1 id="Go实战：Gorilla-WebSocket"><a href="#Go实战：Gorilla-WebSocket" class="headerlink" title="Go实战：Gorilla WebSocket"></a>Go实战：Gorilla WebSocket</h1><blockquote>
<p>Github：<a href="https://github.com/gorilla/websocket" target="_blank" rel="noopener">https://github.com/gorilla/websocket</a></p>
</blockquote>
<p>文件监控例子（当文件被修改后，把文件发给客户端）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.HandleFunc(<span class="string">"/ws"</span>, serveWs)</span><br><span class="line">   <span class="keyword">if</span> err := http.ListenAndServe(*addr, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveWs</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   <span class="comment">//升级为Websocket协议</span></span><br><span class="line">   ws, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> _, ok := err.(websocket.HandshakeError); !ok &#123;</span><br><span class="line">         log.Println(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> lastMod time.Time</span><br><span class="line">   <span class="keyword">if</span> n, err := strconv.ParseInt(r.FormValue(<span class="string">"lastMod"</span>), <span class="number">16</span>, <span class="number">64</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      lastMod = time.Unix(<span class="number">0</span>, n)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> writer(ws, lastMod) <span class="comment">//发送数据、Pong</span></span><br><span class="line">   reader(ws) <span class="comment">//读数据、处理Ping</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writer</span><span class="params">(ws *websocket.Conn, lastMod time.Time)</span></span> &#123;</span><br><span class="line">   pingTicker := time.NewTicker(pingPeriod)</span><br><span class="line">   fileTicker := time.NewTicker(filePeriod)</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-fileTicker.C:</span><br><span class="line">         p, fileModified, err := readFileIfModified(lastMod)</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">if</span> fileModified &#123;</span><br><span class="line">            ws.SetWriteDeadline(time.Now().Add(writeWait))</span><br><span class="line">            <span class="keyword">if</span> err := ws.WriteMessage(websocket.TextMessage, p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">case</span> &lt;-pingTicker.C:</span><br><span class="line">         ws.SetWriteDeadline(time.Now().Add(writeWait))</span><br><span class="line">         <span class="keyword">if</span> err := ws.WriteMessage(websocket.PingMessage, []<span class="keyword">byte</span>&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reader</span><span class="params">(ws *websocket.Conn)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> ws.Close()</span><br><span class="line">   ws.SetReadLimit(<span class="number">512</span>)</span><br><span class="line">   ws.SetReadDeadline(time.Now().Add(pongWait))</span><br><span class="line">   ws.SetPongHandler(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; ws.SetReadDeadline(time.Now().Add(pongWait)); <span class="keyword">return</span> <span class="literal">nil</span> &#125;)</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      _, _, err := ws.ReadMessage()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最重要的几个方法是Upgrade、ReadMessage和WriteMessage，下面逐一介绍。</p>
<h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><p>协议升级</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Upgrade upgrades the HTTP server connection to the WebSocket protocol.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *Upgrader)</span> <span class="title">Upgrade</span><span class="params">(w http.ResponseWriter, r *http.Request, responseHeader http.Header)</span> <span class="params">(*Conn, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> badHandshake = <span class="string">"websocket: the client is not using the websocket protocol: "</span></span><br><span class="line">   <span class="comment">//检查必要的头部字段</span></span><br><span class="line">   <span class="keyword">if</span> !tokenListContainsValue(r.Header, <span class="string">"Connection"</span>, <span class="string">"upgrade"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> u.returnError(w, r, http.StatusBadRequest, badHandshake+<span class="string">"'upgrade' token not found in 'Connection' header"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !tokenListContainsValue(r.Header, <span class="string">"Upgrade"</span>, <span class="string">"websocket"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> u.returnError(w, r, http.StatusBadRequest, badHandshake+<span class="string">"'websocket' token not found in 'Upgrade' header"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> r.Method != <span class="string">"GET"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> u.returnError(w, r, http.StatusMethodNotAllowed, badHandshake+<span class="string">"request method is not GET"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !tokenListContainsValue(r.Header, <span class="string">"Sec-Websocket-Version"</span>, <span class="string">"13"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> u.returnError(w, r, http.StatusBadRequest, <span class="string">"websocket: unsupported version: 13 not found in 'Sec-Websocket-Version' header"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !checkOrigin(r) &#123;</span><br><span class="line">      <span class="keyword">return</span> u.returnError(w, r, http.StatusForbidden, <span class="string">"websocket: request origin not allowed by Upgrader.CheckOrigin"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   challengeKey := r.Header.Get(<span class="string">"Sec-Websocket-Key"</span>)</span><br><span class="line">   <span class="keyword">if</span> challengeKey == <span class="string">""</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> u.returnError(w, r, http.StatusBadRequest, <span class="string">"websocket: not a websocket handshake: 'Sec-WebSocket-Key' header is missing or blank"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   h, ok := w.(http.Hijacker)</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> u.returnError(w, r, http.StatusInternalServerError, <span class="string">"websocket: response does not implement http.Hijacker"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建websocket.Conn</span></span><br><span class="line">   c := newConn(netConn, <span class="literal">true</span>, u.ReadBufferSize, u.WriteBufferSize, u.WriteBufferPool, br, writeBuf)</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">var</span> p []<span class="keyword">byte</span></span><br><span class="line">   p = <span class="built_in">append</span>(p, <span class="string">"HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "</span>...)</span><br><span class="line">   p = <span class="built_in">append</span>(p, computeAcceptKey(challengeKey)...) <span class="comment">//计算accept</span></span><br><span class="line">   p = <span class="built_in">append</span>(p, <span class="string">"\r\n"</span>...)</span><br><span class="line">   <span class="keyword">if</span> c.subprotocol != <span class="string">""</span> &#123;</span><br><span class="line">      p = <span class="built_in">append</span>(p, <span class="string">"Sec-WebSocket-Protocol: "</span>...)</span><br><span class="line">      p = <span class="built_in">append</span>(p, c.subprotocol...)</span><br><span class="line">      p = <span class="built_in">append</span>(p, <span class="string">"\r\n"</span>...)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> _, err = netConn.Write(p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      netConn.Close()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keyGUID = []<span class="keyword">byte</span>(<span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeAcceptKey</span><span class="params">(challengeKey <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   h := sha1.New()</span><br><span class="line">   h.Write([]<span class="keyword">byte</span>(challengeKey))</span><br><span class="line">   h.Write(keyGUID)</span><br><span class="line">   <span class="keyword">return</span> base64.StdEncoding.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConn</span><span class="params">(conn net.Conn, isServer <span class="keyword">bool</span>, readBufferSize, writeBufferSize <span class="keyword">int</span>, writeBufferPool BufferPool, br *bufio.Reader, writeBuf []<span class="keyword">byte</span>)</span> *<span class="title">Conn</span></span> &#123;</span><br><span class="line">   c := &amp;Conn&#123;</span><br><span class="line">      isServer:               isServer,</span><br><span class="line">      br:                     br,</span><br><span class="line">      conn:                   conn,</span><br><span class="line">      mu:                     mu,</span><br><span class="line">      readFinal:              <span class="literal">true</span>,</span><br><span class="line">      writeBuf:               writeBuf,</span><br><span class="line">      writePool:              writeBufferPool,</span><br><span class="line">      writeBufSize:           writeBufferSize,</span><br><span class="line">      enableWriteCompression: <span class="literal">true</span>,</span><br><span class="line">      compressionLevel:       defaultCompressionLevel,</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//设置对应的消息处理Handler</span></span><br><span class="line">   c.SetCloseHandler(<span class="literal">nil</span>)</span><br><span class="line">   c.SetPingHandler(<span class="literal">nil</span>)</span><br><span class="line">   c.SetPongHandler(<span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetCloseHandler</span><span class="params">(h <span class="keyword">func</span>(code <span class="keyword">int</span>, text <span class="keyword">string</span>)</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">      h = <span class="function"><span class="keyword">func</span><span class="params">(code <span class="keyword">int</span>, text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">         message := FormatCloseMessage(code, <span class="string">""</span>)</span><br><span class="line">         c.WriteControl(CloseMessage, message, time.Now().Add(writeWait))</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   c.handleClose = h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetPingHandler</span><span class="params">(h <span class="keyword">func</span>(appData <span class="keyword">string</span>)</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">      h = <span class="function"><span class="keyword">func</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">         err := c.WriteControl(PongMessage, []<span class="keyword">byte</span>(message), time.Now().Add(writeWait))</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   c.handlePing = h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">SetPongHandler</span><span class="params">(h <span class="keyword">func</span>(appData <span class="keyword">string</span>)</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">      h = <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   c.handlePong = h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReadMessage"><a href="#ReadMessage" class="headerlink" title="ReadMessage"></a>ReadMessage</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Conn)</span></span> <span class="type">ReadMessage</span>() (messageType int, p []byte, err error) &#123;</span><br><span class="line">   <span class="keyword">var</span> r io.<span class="type">Reader</span></span><br><span class="line">   messageType, r, err = <span class="built_in">c</span>.<span class="type">NextReader</span>()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> messageType, <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   p, err = ioutil.<span class="type">ReadAll</span>(r)</span><br><span class="line">   <span class="keyword">return</span> messageType, p, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Conn)</span></span> <span class="type">NextReader</span>() (messageType int, r io.<span class="type">Reader</span>, err error) &#123;</span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">c</span>.readErr == <span class="literal">nil</span> &#123;</span><br><span class="line">       frameType, err := <span class="built_in">c</span>.advanceFrame()</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="built_in">c</span>.readErr = hideTempErr(err)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> frameType == <span class="type">TextMessage</span> || frameType == <span class="type">BinaryMessage</span> &#123;</span><br><span class="line">          <span class="built_in">c</span>.messageReader = &amp;messageReader&#123;<span class="built_in">c</span>&#125;</span><br><span class="line">          <span class="built_in">c</span>.reader = <span class="built_in">c</span>.messageReader</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">c</span>.readDecompress &#123;</span><br><span class="line">             <span class="built_in">c</span>.reader = <span class="built_in">c</span>.newDecompressionReader(<span class="built_in">c</span>.reader)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> frameType, <span class="built_in">c</span>.reader, <span class="literal">nil</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据帧</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Conn)</span></span> advanceFrame() (int, error) &#123;</span><br><span class="line">   p, err := <span class="built_in">c</span>.read(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">final</span> := p[<span class="number">0</span>]&amp;finalBit != <span class="number">0</span></span><br><span class="line">   frameType := int(p[<span class="number">0</span>] &amp; <span class="number">0xf</span>)</span><br><span class="line">   mask := p[<span class="number">1</span>]&amp;maskBit != <span class="number">0</span></span><br><span class="line">   <span class="built_in">c</span>.setReadRemaining(int64(p[<span class="number">1</span>] &amp; <span class="number">0x7f</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> frameType &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">CloseMessage</span>, <span class="type">PingMessage</span>, <span class="type">PongMessage</span>:</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">c</span>.readRemaining &gt; maxControlFramePayloadSize &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"control frame length &gt; 125"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !<span class="keyword">final</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"control frame not final"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">TextMessage</span>, <span class="type">BinaryMessage</span>:</span><br><span class="line">      <span class="keyword">if</span> !<span class="built_in">c</span>.readFinal &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"message start before final message frame"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">c</span>.readFinal = <span class="keyword">final</span></span><br><span class="line">   <span class="keyword">case</span> continuationFrame:</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">c</span>.readFinal &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"continuation after final message frame"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">c</span>.readFinal = <span class="keyword">final</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"unknown opcode "</span> + strconv.<span class="type">Itoa</span>(frameType))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">switch</span> <span class="built_in">c</span>.readRemaining &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">126</span>:</span><br><span class="line">      p, err := <span class="built_in">c</span>.read(<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">c</span>.setReadRemaining(int64(binary.<span class="type">BigEndian</span>.<span class="type">Uint16</span>(p))); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, err</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">127</span>:</span><br><span class="line">      p, err := <span class="built_in">c</span>.read(<span class="number">8</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">c</span>.setReadRemaining(int64(binary.<span class="type">BigEndian</span>.<span class="type">Uint64</span>(p))); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> mask != <span class="built_in">c</span>.isServer &#123;</span><br><span class="line">      <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"incorrect mask flag"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> mask &#123;</span><br><span class="line">      <span class="built_in">c</span>.readMaskPos = <span class="number">0</span></span><br><span class="line">      p, err := <span class="built_in">c</span>.read(len(<span class="built_in">c</span>.readMaskKey))</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, err</span><br><span class="line">      &#125;</span><br><span class="line">      copy(<span class="built_in">c</span>.readMaskKey[:], p)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//处理控制帧</span></span><br><span class="line">   <span class="keyword">switch</span> frameType &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">PongMessage</span>:</span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">c</span>.handlePong(string(payload)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, err</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">PingMessage</span>:</span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">c</span>.handlePing(string(payload)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, err</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">CloseMessage</span>:</span><br><span class="line">      closeCode := <span class="type">CloseNoStatusReceived</span></span><br><span class="line">      closeText := <span class="string">""</span></span><br><span class="line">      <span class="keyword">if</span> len(payload) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">         closeCode = int(binary.<span class="type">BigEndian</span>.<span class="type">Uint16</span>(payload))</span><br><span class="line">         <span class="keyword">if</span> !isValidReceivedCloseCode(closeCode) &#123;</span><br><span class="line">            <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"invalid close code"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         closeText = string(payload[<span class="number">2</span>:])</span><br><span class="line">         <span class="keyword">if</span> !utf8.<span class="type">ValidString</span>(closeText) &#123;</span><br><span class="line">            <span class="keyword">return</span> noFrame, <span class="built_in">c</span>.handleProtocolError(<span class="string">"invalid utf8 payload in close frame"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err := <span class="built_in">c</span>.handleClose(closeCode, closeText); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> noFrame, err</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> noFrame, &amp;<span class="type">CloseError</span>&#123;<span class="type">Code</span>: closeCode, <span class="type">Text</span>: closeText&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> frameType, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteMessage"><a href="#WriteMessage" class="headerlink" title="WriteMessage"></a>WriteMessage</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Conn)</span></span> <span class="type">WriteMessage</span>(messageType int, data []byte) error &#123;</span><br><span class="line">   <span class="keyword">var</span> mw messageWriter</span><br><span class="line">   <span class="comment">// beginMessage prepares a connection and message writer for a new message.</span></span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">c</span>.beginMessage(&amp;mw, messageType); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    n := copy(<span class="built_in">c</span>.writeBuf[mw.pos:], data)</span><br><span class="line">    mw.pos += n</span><br><span class="line">    data = data[n:]</span><br><span class="line">    <span class="keyword">return</span> mw.flushFrame(<span class="literal">true</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组装数据帧</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *messageWriter)</span></span> flushFrame(<span class="keyword">final</span> bool, extra []byte) error &#123;</span><br><span class="line">   <span class="built_in">c</span> := w.<span class="built_in">c</span></span><br><span class="line">   length := w.pos - maxFrameHeaderSize + len(extra)</span><br><span class="line"></span><br><span class="line">   b0 := byte(w.frameType)</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">final</span> &#123;</span><br><span class="line">      b0 |= finalBit</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> w.compress &#123;</span><br><span class="line">      b0 |= rsv1Bit</span><br><span class="line">   &#125;</span><br><span class="line">   w.compress = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   b1 := byte(<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> !<span class="built_in">c</span>.isServer &#123;</span><br><span class="line">      b1 |= maskBit</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Assume that the frame starts at beginning of c.writeBuf.</span></span><br><span class="line">   framePos := <span class="number">0</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">c</span>.isServer &#123;</span><br><span class="line">      <span class="comment">// Adjust up if mask not included in the header.</span></span><br><span class="line">      framePos = <span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> length &gt;= <span class="number">65536</span>:</span><br><span class="line">      <span class="built_in">c</span>.writeBuf[framePos] = b0</span><br><span class="line">      <span class="built_in">c</span>.writeBuf[framePos+<span class="number">1</span>] = b1 | <span class="number">127</span></span><br><span class="line">      binary.<span class="type">BigEndian</span>.<span class="type">PutUint64</span>(<span class="built_in">c</span>.writeBuf[framePos+<span class="number">2</span>:], uint64(length))</span><br><span class="line">   <span class="keyword">case</span> length &gt; <span class="number">125</span>:</span><br><span class="line">      framePos += <span class="number">6</span></span><br><span class="line">      <span class="built_in">c</span>.writeBuf[framePos] = b0</span><br><span class="line">      <span class="built_in">c</span>.writeBuf[framePos+<span class="number">1</span>] = b1 | <span class="number">126</span></span><br><span class="line">      binary.<span class="type">BigEndian</span>.<span class="type">PutUint16</span>(<span class="built_in">c</span>.writeBuf[framePos+<span class="number">2</span>:], uint16(length))</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      framePos += <span class="number">8</span></span><br><span class="line">      <span class="built_in">c</span>.writeBuf[framePos] = b0</span><br><span class="line">      <span class="built_in">c</span>.writeBuf[framePos+<span class="number">1</span>] = b1 | byte(length)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !<span class="built_in">c</span>.isServer &#123;</span><br><span class="line">      key := newMaskKey()</span><br><span class="line">      copy(<span class="built_in">c</span>.writeBuf[maxFrameHeaderSize-<span class="number">4</span>:], key[:])</span><br><span class="line">      maskBytes(key, <span class="number">0</span>, <span class="built_in">c</span>.writeBuf[maxFrameHeaderSize:w.pos])</span><br><span class="line">      <span class="keyword">if</span> len(extra) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> w.endMessage(<span class="built_in">c</span>.writeFatal(errors.<span class="type">New</span>(<span class="string">"websocket: internal error, extra used in client mode"</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Write the buffers to the connection with best-effort detection of</span></span><br><span class="line">   <span class="comment">// concurrent writes. See the concurrency section in the package</span></span><br><span class="line">   <span class="comment">// documentation for more info.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">c</span>.isWriting &#123;</span><br><span class="line">      panic(<span class="string">"concurrent write to websocket connection"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">c</span>.isWriting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">   err := <span class="built_in">c</span>.write(w.frameType, <span class="built_in">c</span>.writeDeadline, <span class="built_in">c</span>.writeBuf[framePos:w.pos], extra)</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ref：</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6455#" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/html/rfc6455#</a></li>
<li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/WebSocket</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></li>
<li><a href="https://pkg.go.dev/github.com/gorilla/websocket" target="_blank" rel="noopener">https://pkg.go.dev/github.com/gorilla/websocket</a></li>
</ul>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Consul入门手册</title>
    <url>/2020/01/30/Manual-of-consul/</url>
    <content><![CDATA[<h1 id="Consul是什么？"><a href="#Consul是什么？" class="headerlink" title="Consul是什么？"></a>Consul是什么？</h1><p>Consul是一个服务发现和配置工具，它是分布式和高可用的，而且极易扩展。</p>
<p>Consul主要提供了以下特性：</p>
<ol>
<li>服务发现：Consul使得服务注册和服务发现（通过DNS或HTTP接口）变得非常简单。</li>
<li>健康检查：健康检查使得Consul可以快速向管理员报告集群状况。将它与服务发现集成，可以防止流量路由到故障节点，实现服务熔断。</li>
<li>KV存储：灵活的KV存储，可用于尺寸出动态配置、功能特性、协调信息和选举信息等。简单的HTTP API使其易于在任何地方地方。</li>
<li>多数据中心：Consul支持多数据中心，不需要负责的配置就可以支持任意数量的数据中心。</li>
<li>服务鉴权（Service Segmentation）：Consul连接基于自动TLS加密和基于签名的鉴权实现安全的服务间通信。</li>
</ol>
<p>Consul支持Linux, Mac OS X, FreeBSD, Solaris, Windows等操作系统。</p>
<a id="more"></a>

<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>每个提供服务给Consul的节点都运行了一个Consul Agent。运行一个Agent并不需要对其他服务做发现或读写KV存储。Agent负责对该节点上的服务做健康检查。</p>
<p>Agent会与一个或多个Consul Server通信。Consul Server通常有多个实例，负责数据存储和备份、选举主节点等。虽然Consul支持在只有一个Server实例的情况下工具，但通常推荐使用3至5个实例，从而避免由于某些异常场景而导致数据丢失。同时，推荐在每个数据中心部署一个Consul集群。</p>
<p>每个数据中运行了一个Consul server集群。当一个跨数据中心的服务发现和配置请求创建时，本地Consul Server转发请求到远程的数据中心并返回结果.</p>
<h1 id="安装Consul"><a href="#安装Consul" class="headerlink" title="安装Consul"></a>安装Consul</h1><p>Consul集群的每个节点都必须先安装Consul，安装非常简单。在Mac上安装Consul命令如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>consul</span><br></pre></td></tr></table></figure>
<p>安装成功后执行consul命令输出如下结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ consul</span><br><span class="line">Usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line">    acl            Interact with Consul<span class="string">'s ACLs</span></span><br><span class="line"><span class="string">    agent          Runs a Consul agent</span></span><br><span class="line"><span class="string">    catalog        Interact with the catalog</span></span><br><span class="line"><span class="string">    config         Interact with Consul'</span>s Centralized Configurations</span><br><span class="line">    connect        Interact with Consul Connect</span><br><span class="line">    <span class="builtin-name">debug</span>          Records a debugging archive <span class="keyword">for</span> operators</span><br><span class="line">    event          Fire a new event</span><br><span class="line">    exec           Executes a command on Consul nodes</span><br><span class="line">    force-leave    Forces a member of the cluster <span class="keyword">to</span> enter the <span class="string">"left"</span> state</span><br><span class="line">    <span class="builtin-name">info</span>           Provides debugging information <span class="keyword">for</span> operators.</span><br><span class="line">    intention      Interact with Connect<span class="built_in"> service </span>intentions</span><br><span class="line">    join           Tell Consul agent <span class="keyword">to</span> join cluster</span><br><span class="line">    keygen         Generates a new encryption key</span><br><span class="line">    keyring        Manages gossip layer encryption keys</span><br><span class="line">    kv             Interact with the key-value store</span><br><span class="line">    leave          Gracefully leaves the Consul cluster <span class="keyword">and</span> shuts down</span><br><span class="line">    lock           Execute a command holding a lock</span><br><span class="line">    login          Login <span class="keyword">to</span> Consul using an auth method</span><br><span class="line">    logout         Destroy a Consul token created with login</span><br><span class="line">    maint          Controls node <span class="keyword">or</span><span class="built_in"> service </span>maintenance mode</span><br><span class="line">    members        Lists the members of a Consul cluster</span><br><span class="line">    monitor        Stream logs <span class="keyword">from</span> a Consul agent</span><br><span class="line">    operator       Provides cluster-level tools <span class="keyword">for</span> Consul operators</span><br><span class="line">    reload         Triggers the agent <span class="keyword">to</span> reload configuration files</span><br><span class="line">    rtt            Estimates<span class="built_in"> network </span>round trip time between nodes</span><br><span class="line">    services       Interact with services</span><br><span class="line">    snapshot       Saves, restores <span class="keyword">and</span> inspects snapshots of Consul<span class="built_in"> server </span>state</span><br><span class="line">    tls            Builtin helpers <span class="keyword">for</span> creating CAs <span class="keyword">and</span> certificates</span><br><span class="line">    validate       Validate<span class="built_in"> config </span>files/directories</span><br><span class="line">    version        Prints the Consul version</span><br><span class="line">    watch          Watch <span class="keyword">for</span> changes <span class="keyword">in</span> Consul</span><br></pre></td></tr></table></figure>

<h1 id="运行Agent"><a href="#运行Agent" class="headerlink" title="运行Agent"></a>运行Agent</h1><p>完成Consul的安装后，可运行Agent。Agent可以运行为Server或Client模式。每个数据中心至少必须拥有一台server，建议在一个集群中部署或者3至5个Server。部署单一的Server，在出现失败时会不可避免的造成数据丢失.</p>
<p>其他的Agent运行为Client模式，一个Client是一个非常轻量级的进程，用于注册服务，运行健康检查和转发对Server的查询，Agent必须在集群中的每个主机上运行。</p>
<h2 id="启动Agent"><a href="#启动Agent" class="headerlink" title="启动Agent"></a>启动Agent</h2><p>命令<code>consul agent -dev</code>可以启动一个开发模式的Agent，这种模式不能用于生产环境，因为它不持久化任何状态。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ consul agent -dev</span><br><span class="line">==&gt; Starting Consul agent...</span><br><span class="line">           Version: <span class="string">'v1.6.1'</span></span><br><span class="line">           Node ID: <span class="string">'2e524113-7caf-643a-80bb-a2fa00c2673b'</span></span><br><span class="line">         Node name: <span class="string">'C02Z35N9LVCF'</span></span><br><span class="line">        Datacenter: <span class="string">'dc1'</span> (Segment: <span class="string">'&lt;all&gt;'</span>)</span><br><span class="line">            Server: <span class="literal">true</span> (Bootstrap: <span class="literal">false</span>)</span><br><span class="line">       Client Addr: [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] (HTTP: <span class="number">8500</span>, HTTPS: <span class="number">-1</span>, gRPC: <span class="number">8502</span>, DNS: <span class="number">8600</span>)</span><br><span class="line">      Cluster Addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> (LAN: <span class="number">8301</span>, WAN: <span class="number">8302</span>)</span><br><span class="line">           Encrypt: Gossip: <span class="literal">false</span>, TLS-Outgoing: <span class="literal">false</span>, TLS-Incoming: <span class="literal">false</span>, Auto-Encrypt-TLS: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">==&gt; Log data will now stream <span class="keyword">in</span> as it occurs:</span><br><span class="line"></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] agent: Using random ID <span class="string">"2e524113-7caf-643a-80bb-a2fa00c2673b"</span> as node ID</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] tlsutil: Update with version <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] tlsutil: OutgoingRPCWrapper with version <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO]  raft: Initial configuration (index=<span class="number">1</span>): [&#123;Suffrage:Voter ID:<span class="number">2e524113</span><span class="number">-7</span>caf<span class="number">-643</span>a<span class="number">-80</span>bb-a2fa00c2673b Address:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span>&#125;]</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO]  raft: Node at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span> [Follower] entering Follower state (Leader: <span class="string">""</span>)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] serf: EventMemberJoin: C02Z35N9LVCF.dc1 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] serf: EventMemberJoin: C02Z35N9LVCF <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] consul: Adding LAN server C02Z35N9LVCF (Addr: tcp/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span>) (DC: dc1)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] consul: Handled member-join event <span class="keyword">for</span> server <span class="string">"C02Z35N9LVCF.dc1"</span> <span class="keyword">in</span> area <span class="string">"wan"</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] agent: Started DNS server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8600</span> (tcp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] agent: Started DNS server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8600</span> (udp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] agent: Started HTTP server on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8500</span> (tcp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] agent: Started gRPC server on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8502</span> (tcp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] agent: started state syncer</span><br><span class="line">==&gt; Consul agent running!</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [WARN]  raft: Heartbeat timeout <span class="keyword">from</span> <span class="string">""</span> reached, starting election</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO]  raft: Node at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span> [Candidate] entering Candidate state <span class="keyword">in</span> term <span class="number">2</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] raft: Votes needed: <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] raft: Vote granted <span class="keyword">from</span> <span class="number">2e524113</span><span class="number">-7</span>caf<span class="number">-643</span>a<span class="number">-80</span>bb-a2fa00c2673b <span class="keyword">in</span> term <span class="number">2.</span> Tally: <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO]  raft: Election won. Tally: <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO]  raft: Node at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span> [Leader] entering Leader state</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] consul: cluster leadership acquired</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] consul: New leader elected: C02Z35N9LVCF</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] connect: initialized primary datacenter CA with provider <span class="string">"consul"</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] consul: Skipping self join check <span class="keyword">for</span> <span class="string">"C02Z35N9LVCF"</span> since the cluster <span class="keyword">is</span> too small</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] consul: member <span class="string">'C02Z35N9LVCF'</span> joined, marking health alive</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] agent: Skipping remote check <span class="string">"serfHealth"</span> since it <span class="keyword">is</span> managed <span class="built_in">auto</span>matically</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [INFO] agent: Synced node info</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] agent: Node info <span class="keyword">in</span> sync</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] agent: Skipping remote check <span class="string">"serfHealth"</span> since it <span class="keyword">is</span> managed <span class="built_in">auto</span>matically</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">09</span> [DEBUG] agent: Node info <span class="keyword">in</span> sync</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">11</span> [DEBUG] tlsutil: OutgoingRPCWrapper with version <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="集群成员"><a href="#集群成员" class="headerlink" title="集群成员"></a>集群成员</h2><p>新开一个终端窗口运行<code>consul members</code>, 就可以看到Consul集群的成员。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ consul members</span><br><span class="line">Node         <span class="built_in"> Address </span>        Status <span class="built_in"> Type </span>   Build  Protocol  DC   Segment</span><br><span class="line">C02Z35N9LVCF  127.0.0.1:8301  alive  <span class="built_in"> server </span> 1.6.1  2         dc1  &lt;all&gt;</span><br></pre></td></tr></table></figure>
<p>以上输出显示了我们自己的节点运行的节点、地址、健康状态、自己在集群中的角色、版本信息等。添加<code>-detailed</code>选项可以查看到额外的信息，如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ consul members --detailed</span><br><span class="line">Node          Address         Status  Tags</span><br><span class="line">C02Z35N9LVCF  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8301</span>  alive   acls=<span class="number">0</span>,build=<span class="number">1.6</span><span class="number">.1</span>:<span class="number">9</span>be6dfc+,dc=dc1,id=<span class="number">2e524113</span><span class="number">-7</span>caf<span class="number">-643</span>a<span class="number">-80</span>bb-a2fa00c2673b,port=<span class="number">8300</span>,raft_vsn=<span class="number">3</span>,role=consul,segment=&lt;all&gt;,vsn=<span class="number">2</span>,vsn_max=<span class="number">3</span>,vsn_min=<span class="number">2</span>,wan_join_port=<span class="number">8302</span></span><br></pre></td></tr></table></figure>
<p><code>members</code>命令的输出是基于gossip协议，它是最终一致的。这意味着，在任何时候，通过你本地Agent看到的结果可能不能准确匹配server的状态。为了查看到一致的信息，可使用HTTP API(将自动转发)到Consul Server上去进行查询：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">localhost:</span><span class="number">8500</span><span class="regexp">/v1/</span>catalog/nodes</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"ID"</span>: <span class="string">"2e524113-7caf-643a-80bb-a2fa00c2673b"</span>,</span><br><span class="line">        <span class="string">"Node"</span>: <span class="string">"C02Z35N9LVCF"</span>,</span><br><span class="line">        <span class="string">"Address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="string">"Datacenter"</span>: <span class="string">"dc1"</span>,</span><br><span class="line">        <span class="string">"TaggedAddresses"</span>: &#123;</span><br><span class="line">            <span class="string">"lan"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"wan"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Meta"</span>: &#123;</span><br><span class="line">            <span class="string">"consul-network-segment"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"CreateIndex"</span>: <span class="number">9</span>,</span><br><span class="line">        <span class="string">"ModifyIndex"</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="停止Agent"><a href="#停止Agent" class="headerlink" title="停止Agent"></a>停止Agent</h2><p>你可以使用 Ctrl-C 优雅的关闭Agent，中断Agent之后你可以看到它离开了集群并关闭.<br>退出后，Consul提醒其他集群成员，这个节点离开了。如果你强行杀掉进程，集群的其他成员应该能检测到这个节点失效了。当一个成员离开，他的服务和检测也会从目录中移除。当一个成员失效了，他的健康状况被简单的标记为危险，但是不会从目录中移除。Consul会自动尝试对失效的节点进行重连，允许他从某些网络条件下恢复过来。</p>
<h1 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h1><p>在之前的步骤我们运行了第一个agent，看到了集群的成员。现在我们将注册第一个服务并查询这些服务。</p>
<h2 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h2><p>可以通过提供服务定义或者调用HTTP API来注册一个服务，服务定义文件是注册服务的最通用的方式。</p>
<p>首先，为Consul配置创建一个目录：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> /etc/consul.d</span><br></pre></td></tr></table></figure>
<p>然后，编写服务定义配置文件。假设我们有一个名叫web的服务运行在 80端口。另外，我们将给他设置一个标签，这样我们可以使用它作为额外的查询方式：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> '&#123;<span class="string">"service"</span>: &#123;<span class="string">"name"</span>: <span class="string">"web"</span>, <span class="string">"tags"</span>: [<span class="string">"rails"</span>], <span class="string">"port"</span>: 80&#125;&#125;' &gt; <span class="string">/etc/consul.d/web.json</span></span><br></pre></td></tr></table></figure>
<p>重新启动Agent，设置配置目录：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ sudo consul agent -dev -config-dir /etc/consul.d/web.json</span><br><span class="line">==&gt; Starting Consul agent...</span><br><span class="line">           Version: <span class="string">'v1.6.1'</span></span><br><span class="line">           Node ID: <span class="string">'feba8d74-4a3a-9b42-305f-eea7da207c9c'</span></span><br><span class="line">         Node name: <span class="string">'C02Z35N9LVCF'</span></span><br><span class="line">        Datacenter: <span class="string">'dc1'</span> (Segment: <span class="string">'&lt;all&gt;'</span>)</span><br><span class="line">            Server: <span class="literal">true</span> (Bootstrap: <span class="literal">false</span>)</span><br><span class="line">       Client Addr: [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>] (HTTP: <span class="number">8500</span>, HTTPS: <span class="number">-1</span>, gRPC: <span class="number">8502</span>, DNS: <span class="number">8600</span>)</span><br><span class="line">      Cluster Addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> (LAN: <span class="number">8301</span>, WAN: <span class="number">8302</span>)</span><br><span class="line">           Encrypt: Gossip: <span class="literal">false</span>, TLS-Outgoing: <span class="literal">false</span>, TLS-Incoming: <span class="literal">false</span>, Auto-Encrypt-TLS: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">==&gt; Log data will now stream <span class="keyword">in</span> as it occurs:</span><br><span class="line"></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [DEBUG] agent: Using random ID <span class="string">"feba8d74-4a3a-9b42-305f-eea7da207c9c"</span> as node ID</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [DEBUG] tlsutil: Update with version <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [DEBUG] tlsutil: OutgoingRPCWrapper with version <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO]  raft: Initial configuration (index=<span class="number">1</span>): [&#123;Suffrage:Voter ID:feba8d74<span class="number">-4</span>a3a<span class="number">-9</span>b42<span class="number">-305f</span>-eea7da207c9c Address:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span>&#125;]</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO]  raft: Node at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span> [Follower] entering Follower state (Leader: <span class="string">""</span>)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] serf: EventMemberJoin: C02Z35N9LVCF.dc1 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] serf: EventMemberJoin: C02Z35N9LVCF <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] consul: Adding LAN server C02Z35N9LVCF (Addr: tcp/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span>) (DC: dc1)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] consul: Handled member-join event <span class="keyword">for</span> server <span class="string">"C02Z35N9LVCF.dc1"</span> <span class="keyword">in</span> area <span class="string">"wan"</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] agent: Started DNS server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8600</span> (tcp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] agent: Started DNS server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8600</span> (udp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] agent: Started HTTP server on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8500</span> (tcp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] agent: Started gRPC server on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8502</span> (tcp)</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">29</span> [INFO] agent: started state syncer</span><br><span class="line">==&gt; Consul agent running!</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [WARN]  raft: Heartbeat timeout <span class="keyword">from</span> <span class="string">""</span> reached, starting election</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO]  raft: Node at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span> [Candidate] entering Candidate state <span class="keyword">in</span> term <span class="number">2</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [DEBUG] raft: Votes needed: <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [DEBUG] raft: Vote granted <span class="keyword">from</span> feba8d74<span class="number">-4</span>a3a<span class="number">-9</span>b42<span class="number">-305f</span>-eea7da207c9c <span class="keyword">in</span> term <span class="number">2.</span> Tally: <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO]  raft: Election won. Tally: <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO]  raft: Node at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8300</span> [Leader] entering Leader state</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO] consul: cluster leadership acquired</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO] consul: New leader elected: C02Z35N9LVCF</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO] connect: initialized primary datacenter CA with provider <span class="string">"consul"</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [DEBUG] consul: Skipping self join check <span class="keyword">for</span> <span class="string">"C02Z35N9LVCF"</span> since the cluster <span class="keyword">is</span> too small</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO] consul: member <span class="string">'C02Z35N9LVCF'</span> joined, marking health alive</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [DEBUG] agent: Skipping remote check <span class="string">"serfHealth"</span> since it <span class="keyword">is</span> managed <span class="built_in">auto</span>matically</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [INFO] agent: Synced service <span class="string">"web"</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">30</span> [DEBUG] agent: Node info <span class="keyword">in</span> sync</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">32</span> [DEBUG] tlsutil: OutgoingRPCWrapper with version <span class="number">1</span></span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">32</span> [DEBUG] agent: Skipping remote check <span class="string">"serfHealth"</span> since it <span class="keyword">is</span> managed <span class="built_in">auto</span>matically</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">32</span> [DEBUG] agent: Service <span class="string">"web"</span> <span class="keyword">in</span> sync</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">32</span> [DEBUG] agent: Node info <span class="keyword">in</span> sync</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">32</span> [DEBUG] agent: Service <span class="string">"web"</span> <span class="keyword">in</span> sync</span><br><span class="line">    <span class="number">2019</span>/<span class="number">11</span>/<span class="number">20</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">32</span> [DEBUG] agent: Node info <span class="keyword">in</span> sync</span><br></pre></td></tr></table></figure>
<p>日志中的<code>Synced service &#39;web&#39;</code>表示Agent从配置文件中载入了服务定义，并且成功注册到服务目录。</p>
<p>如果想注册多个服务，就可以在Consul配置目录创建多个服务定义文件。</p>
<h2 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h2><p>一旦Agent启动并且服务同步了，我们可就以通过DNS或者HTTP API来查询服务。</p>
<h3 id="DNS-API"><a href="#DNS-API" class="headerlink" title="DNS API"></a>DNS API</h3><p>我们首先使用DNS API来查询。在DNS API中，服务的DNS名字是 <code>NAME.service.consul</code>。虽然是可配置的，但默认的所有DNS名字会都在consul命名空间下，这个子域告诉Consul，我们在查询服务，<code>NAME</code>则是服务的名称.</p>
<p>对于我们上面注册的Web服务.它的域名是 <code>web.service.consul</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">dig</span> <span class="string">@127.0.0.1</span> <span class="string">-p</span> <span class="number">8600</span> <span class="string">web.service.consul</span></span><br><span class="line"></span><br><span class="line"><span class="string">;</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">DiG</span> <span class="number">9.10</span><span class="number">.6</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">@127.0.0.1</span> <span class="string">-p</span> <span class="number">8600</span> <span class="string">web.service.consul</span></span><br><span class="line"><span class="string">;</span> <span class="string">(1</span> <span class="string">server</span> <span class="string">found)</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">global options:</span> <span class="string">+cmd</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">Got answer:</span></span><br><span class="line"><span class="string">;;</span> <span class="string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="attr">opcode:</span> <span class="string">QUERY,</span> <span class="attr">status:</span> <span class="string">NOERROR,</span> <span class="attr">id:</span> <span class="number">27222</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">flags:</span> <span class="string">qr</span> <span class="string">aa</span> <span class="string">rd;</span> <span class="attr">QUERY:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">ANSWER:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">AUTHORITY:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">ADDITIONAL:</span> <span class="number">2</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WARNING:</span> <span class="string">recursion</span> <span class="string">requested</span> <span class="string">but</span> <span class="string">not</span> <span class="string">available</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">;</span> <span class="attr">EDNS: version:</span> <span class="number">0</span><span class="string">,</span> <span class="string">flags:;</span> <span class="attr">udp:</span> <span class="number">4096</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">QUESTION SECTION:</span></span><br><span class="line"><span class="string">;web.service.consul.</span>                <span class="string">IN</span>        <span class="string">A</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">ANSWER SECTION:</span></span><br><span class="line"><span class="string">web.service.consul.</span>        <span class="number">0</span>        <span class="string">IN</span>        <span class="string">A</span>        <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">web.service.consul.</span>        <span class="number">0</span>        <span class="string">IN</span>        <span class="string">TXT</span>        <span class="string">"consul-network-segment="</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">Query time:</span> <span class="number">8</span> <span class="string">msec</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">SERVER:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="comment">#8600(127.0.0.1)</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WHEN:</span> <span class="string">Wed</span> <span class="string">Nov</span> <span class="number">20</span> <span class="number">22</span><span class="string">:26:14</span> <span class="string">CST</span> <span class="number">2019</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">MSG SIZE  rcvd:</span> <span class="number">99</span></span><br></pre></td></tr></table></figure>
<p>如你所见,一个A记录返回了一个可用的服务所在的节点的IP地址。A记录只能设置为IP地址，有也可用使用 DNS API 来接收包含地址和端口的 <code>SRV</code> 记录：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">dig</span> <span class="string">@127.0.0.1</span> <span class="string">-p</span> <span class="number">8600</span> <span class="string">web.service.consul</span> <span class="string">SRV</span></span><br><span class="line"></span><br><span class="line"><span class="string">;</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">DiG</span> <span class="number">9.10</span><span class="number">.6</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">@127.0.0.1</span> <span class="string">-p</span> <span class="number">8600</span> <span class="string">web.service.consul</span> <span class="string">SRV</span></span><br><span class="line"><span class="string">;</span> <span class="string">(1</span> <span class="string">server</span> <span class="string">found)</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">global options:</span> <span class="string">+cmd</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">Got answer:</span></span><br><span class="line"><span class="string">;;</span> <span class="string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="attr">opcode:</span> <span class="string">QUERY,</span> <span class="attr">status:</span> <span class="string">NOERROR,</span> <span class="attr">id:</span> <span class="number">49043</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">flags:</span> <span class="string">qr</span> <span class="string">aa</span> <span class="string">rd;</span> <span class="attr">QUERY:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">ANSWER:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">AUTHORITY:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">ADDITIONAL:</span> <span class="number">3</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WARNING:</span> <span class="string">recursion</span> <span class="string">requested</span> <span class="string">but</span> <span class="string">not</span> <span class="string">available</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">;</span> <span class="attr">EDNS: version:</span> <span class="number">0</span><span class="string">,</span> <span class="string">flags:;</span> <span class="attr">udp:</span> <span class="number">4096</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">QUESTION SECTION:</span></span><br><span class="line"><span class="string">;web.service.consul.</span>                <span class="string">IN</span>        <span class="string">SRV</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">ANSWER SECTION:</span></span><br><span class="line"><span class="string">web.service.consul.</span>        <span class="number">0</span>        <span class="string">IN</span>        <span class="string">SRV</span>        <span class="number">1</span> <span class="number">1</span> <span class="number">80</span> <span class="string">C02Z35N9LVCF.node.dc1.consul.</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">C02Z35N9LVCF.node.dc1.consul.</span> <span class="number">0</span>        <span class="string">IN</span>        <span class="string">A</span>        <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="string">C02Z35N9LVCF.node.dc1.consul.</span> <span class="number">0</span>        <span class="string">IN</span>        <span class="string">TXT</span>        <span class="string">"consul-network-segment="</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">Query time:</span> <span class="number">1</span> <span class="string">msec</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">SERVER:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="comment">#8600(127.0.0.1)</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WHEN:</span> <span class="string">Wed</span> <span class="string">Nov</span> <span class="number">20</span> <span class="number">22</span><span class="string">:28:14</span> <span class="string">CST</span> <span class="number">2019</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">MSG SIZE  rcvd:</span> <span class="number">147</span></span><br></pre></td></tr></table></figure>
<p><code>SRV</code>记录告诉我们 web 这个服务运行于节点<code>C02Z35N9LVCF.node.dc1.consul</code> 的80端口，DNS额外返回了节点的A记录。</p>
<p>最后，我们也可以用 DNS API 通过标签来过滤服务，基于标签的服务查询格式为<code>TAG.NAME.service.consul</code>。在下面的例子中，我们请求Consul返回有 rails标签的 web服务：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ dig @<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">8600</span> rails.web.service.consul SRV</span><br><span class="line"># 输出信息略</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h3><p>除了DNS API之外，也可以使用HTTP API查询所有服务实例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ curl http:<span class="regexp">//</span>localhost:<span class="number">8500</span><span class="regexp">/v1/</span>catalog<span class="regexp">/service/</span>web</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"ID"</span>: <span class="string">"feba8d74-4a3a-9b42-305f-eea7da207c9c"</span>,</span><br><span class="line">        <span class="string">"Node"</span>: <span class="string">"C02Z35N9LVCF"</span>,</span><br><span class="line">        <span class="string">"Address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="string">"Datacenter"</span>: <span class="string">"dc1"</span>,</span><br><span class="line">        <span class="string">"TaggedAddresses"</span>: &#123;</span><br><span class="line">            <span class="string">"lan"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"wan"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"NodeMeta"</span>: &#123;</span><br><span class="line">            <span class="string">"consul-network-segment"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ServiceKind"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"ServiceID"</span>: <span class="string">"web"</span>,</span><br><span class="line">        <span class="string">"ServiceName"</span>: <span class="string">"web"</span>,</span><br><span class="line">        <span class="string">"ServiceTags"</span>: [</span><br><span class="line">            <span class="string">"rails"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"ServiceAddress"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"ServiceWeights"</span>: &#123;</span><br><span class="line">            <span class="string">"Passing"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"Warning"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ServiceMeta"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"ServicePort"</span>: <span class="number">80</span>,</span><br><span class="line">        <span class="string">"ServiceEnableTagOverride"</span>: false,</span><br><span class="line">        <span class="string">"ServiceProxy"</span>: &#123;</span><br><span class="line">            <span class="string">"MeshGateway"</span>: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ServiceConnect"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"CreateIndex"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">"ModifyIndex"</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>只查看健康服务实例的方法：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ curl http:<span class="regexp">//</span>localhost:<span class="number">8500</span><span class="regexp">/v1/</span>catalog<span class="regexp">/service/</span>web?passing</span><br><span class="line"><span class="comment"># 输出信息略</span></span><br></pre></td></tr></table></figure>

<h2 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h2><p>服务定义可以通过修改配置文件并发送<code>SIGHUP</code>给Agent来进行更新，这样可以在不关闭服务或者保持服务请求可用的情况下进行更新。</p>
<p>参考来源：</p>
<ol>
<li><a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">https://github.com/hashicorp/consul</a></li>
<li><a href="https://www.consul.io/intro/getting-started.html" target="_blank" rel="noopener">https://www.consul.io/intro/getting-started.html</a></li>
<li><a href="https://book-consul-guide.vnzmi.com/01_what_is_consul.html" target="_blank" rel="noopener">https://book-consul-guide.vnzmi.com/01_what_is_consul.html</a></li>
</ol>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Web Token入门手册</title>
    <url>/2020/01/30/Usage-of-JSON-Web-Token/</url>
    <content><![CDATA[<h1 id="跨域认证问题"><a href="#跨域认证问题" class="headerlink" title="跨域认证问题"></a>跨域认证问题</h1><p>互联网服务离不开用户认证。一般流程是下面这样：</p>
<ol>
<li>用户向服务器发送用户名和密码。</li>
<li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ol>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<ul>
<li>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</li>
<li>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</li>
</ul>
<a id="more"></a>

<h1 id="什么是JWT？"><a href="#什么是JWT？" class="headerlink" title="什么是JWT？"></a>什么是JWT？</h1><p>Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token可直接被用于认证，也可被加密。</p>
<h1 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h1><p>服务器认证以后，生成一个经过签名的 JSON 对象，发回给用户，服务器则不用保存任何 session 数据了。从而把服务器变成无状态的，易于实现扩展。</p>
<h1 id="JWT-的使用场景"><a href="#JWT-的使用场景" class="headerlink" title="JWT 的使用场景"></a>JWT 的使用场景</h1><p>以下是两个JWT的应用场景：</p>
<ol>
<li>鉴权：这是JWT最常见的应用场景。当用户登录成功后，随后的每个请求都将带上JWT，从而允许用户访问被授权的服务和资源。由于它开销小切易于使用，当前被广泛应用于单点登录（Single Sign On）。</li>
<li>信息交换：JWT是不同组织间交换信息的一种很好的方式。因为JWT可以被签名（例如，通过公钥/私钥对），你可以确信信息发送者就是它们说声明的身份。此外，签名是用Header和Payload计算出来的，你可以验证内容是否被篡改。</li>
</ol>
<h1 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h1><p>扁平化形式的JWT是由通过 <code>.</code> 分隔的三部分组成，他们分别是：</p>
<ul>
<li><code>Header</code></li>
<li><code>Payload</code></li>
<li><code>Signature</code></li>
</ul>
<p>所以，一个JWT看起来通常是如下的形式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">xxxxx</span><span class="selector-class">.yyyyy</span><span class="selector-class">.zzzzz</span></span><br></pre></td></tr></table></figure>

<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>头部由两部分组成：</p>
<ul>
<li>token类型，即JWT；</li>
<li>签名算法，例如HMAC SHA256或RSA。</li>
</ul>
<p>一个Header的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后，以上JSON对象会通过 <code>Base64Url</code> 编码为JWT的第一部分。</p>
<h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>标准中注册的声明：</strong></p>
<ul>
<li>iss: jwt签发者</li>
<li>sub: jwt所面向的用户</li>
<li>aud: 接收jwt的一方</li>
<li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat: jwt的签发时间</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li>
</ul>
<p><strong>公共的声明 ：</strong><br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p><strong>私有的声明 ：</strong><br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>一个Payload的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后，Payload会通过 <code>Base64Url</code> 编码为JWT的第二部分。</p>
<h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p>创建签名需要用到编码后的 Header、编码后的 Payload、秘钥、Header中指定的算法。</p>
<p>如果你想使用HMAC SHA256算法，签名将通过如下方式生成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<p>如果你想把以上概念付诸实践，可以通过 <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a> 提供的工具来玩一玩 JWT 。如下图所示：<img src="jwt-example.png" alt="jwt.io"></p>
<h1 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>
<p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h1 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h1><ul>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>Go语言版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"crypto/rsa"</span></span><br><span class="line">	<span class="string">"crypto/x509"</span></span><br><span class="line">	<span class="string">"encoding/pem"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/dgrijalva/jwt-go"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrVerifyFailed = fmt.Errorf(<span class="string">"verify failed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://godoc.org/github.com/dgrijalva/jwt-go#example-New--Hmac</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateToken</span><span class="params">(claims jwt.MapClaims, privateKey []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodRS512, claims)</span><br><span class="line"></span><br><span class="line">	block, _ := pem.Decode(privateKey)</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"private key error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priv, err := x509.ParsePKCS8PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> token.SignedString(priv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://godoc.org/github.com/dgrijalva/jwt-go#example-Parse--Hmac</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyToken</span><span class="params">(tokenString <span class="keyword">string</span>, publicKey []<span class="keyword">byte</span>)</span> <span class="params">(jwt.MapClaims, error)</span></span> &#123;</span><br><span class="line">	token, err := jwt.Parse(tokenString, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := token.Method.(*jwt.SigningMethodRSA); !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unexpected signing method: %v"</span>, token.Header[<span class="string">"alg"</span>])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> token.Header[<span class="string">"alg"</span>] != <span class="string">"RS512"</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unexpected siging alg: %v"</span>, token.Header[<span class="string">"alg"</span>])</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		block, _ := pem.Decode(publicKey)</span><br><span class="line">		<span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ErrVerifyFailed</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ErrVerifyFailed</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pub := pubInterface.(*rsa.PublicKey)</span><br><span class="line">		<span class="keyword">return</span> pub, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrVerifyFailed</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid &#123;</span><br><span class="line">		<span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, ErrVerifyFailed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考来源：</p>
<ol>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></li>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener">https://www.jianshu.com/p/576dbf44b2ae</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li>
</ol>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker之容器使用</title>
    <url>/2020/01/30/Usage-of-docker-container/</url>
    <content><![CDATA[<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker pull ubuntu</span><br></pre></td></tr></table></figure>

<h2 id="启动容器："><a href="#启动容器：" class="headerlink" title="启动容器："></a>启动容器：</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">run</span> -<span class="keyword">it</span> ubuntu /bin/bash</span><br><span class="line"><span class="comment"># 要退出终端，直接输入 exit</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker ps -a</span><br></pre></td></tr></table></figure>

<h2 id="启动已停止运行的容器-1"><a href="#启动已停止运行的容器-1" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ docker <span class="literal">start</span> b750bbbcfd88</span><br></pre></td></tr></table></figure>

<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">run</span> -itd <span class="comment">--name ubuntu-test ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<h2 id="停止一个容器"><a href="#停止一个容器" class="headerlink" title="停止一个容器"></a>停止一个容器</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">stop</span> &lt;容器 <span class="keyword">ID</span>&gt;</span><br></pre></td></tr></table></figure>

<p>停止的容器可以通过 docker restart 重启：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ docker restart <span class="tag">&lt;<span class="name">容器</span> <span class="attr">ID</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><code>docker attach</code>： 如果从这个容器退出（<code>exit</code>），会导致容器的停止。</li>
<li><code>docker exec</code>：推荐大家使用 <code>docker exec</code> 命令，因为此退出容器终端，不会导致容器的停止。</li>
</ul>
<p>exec命令使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span></span><br></pre></td></tr></table></figure>

<h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">$ docker ex<span class="keyword">port</span> 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>


<h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cat docker/ubuntu.tar | docker <span class="keyword">import</span> - test/<span class="symbol">ubuntu:</span>v1</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">import</span> docker<span class="regexp">/ubuntu.tar test/</span><span class="string">ubuntu:</span>v1</span><br></pre></td></tr></table></figure>

<p>也可以通过指定 URL 或者某个目录来导入，例如：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker <span class="keyword">import</span> <span class="symbol">http:</span>/<span class="regexp">/example.com/exampleimage</span>.tgz example/imagerepo</span><br></pre></td></tr></table></figure>

<p>参考来源：</p>
<p>[1] <a href="https://www.runoob.com/docker/docker-container-usage.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-container-usage.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker之镜像使用</title>
    <url>/2020/01/30/Usage-of-docker-image/</url>
    <content><![CDATA[<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>用法：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker pull [OPTIONS] NAME[<span class="symbol">:TAG|</span><span class="variable">@DIGEST</span>]</span><br></pre></td></tr></table></figure>
<p>例如：<code>docker pull ubuntu:18.04</code></p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--rm ubuntu:18.04 bash</span></span><br></pre></td></tr></table></figure>
<p>简要的说明一下上面用到的参数:</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>表示交互式操作，一个是<code>-t</code>表示终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用<code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li>
</ul>
<a id="more"></a>

<h2 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h2><p>使用<code>docker image ls</code>或者<code>docker images</code>:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              <span class="number">18.04</span>               <span class="number">93f</span>d78260bd1        <span class="number">5</span> weeks ago         <span class="number">86.2</span>MB</span><br><span class="line">ubuntu              latest              <span class="number">93f</span>d78260bd1        <span class="number">5</span> weeks ago         <span class="number">86.2</span>MB</span><br><span class="line">hello-world         latest              <span class="number">4</span>ab4c602aa5e        <span class="number">3</span> months ago        <span class="number">1.84</span>kB</span><br><span class="line"></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              <span class="number">18.04</span>               <span class="number">93f</span>d78260bd1        <span class="number">5</span> weeks ago         <span class="number">86.2</span>MB</span><br><span class="line">ubuntu              latest              <span class="number">93f</span>d78260bd1        <span class="number">5</span> weeks ago         <span class="number">86.2</span>MB</span><br><span class="line">hello-world         latest              <span class="number">4</span>ab4c602aa5e        <span class="number">3</span> months ago        <span class="number">1.84</span>kB</span><br></pre></td></tr></table></figure>
<p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p>
<h2 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h2><p>这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ docker<span class="built_in"> system </span>df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              2                   2                   86.18MB             0B (0%)</span><br><span class="line">Containers          14                  2                   148B                25B (16%)</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure>

<h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为<code>&lt;none&gt;</code>的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) 。</p>
<h2 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h2><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">image</span> <span class="keyword">ls</span> -a</span><br></pre></td></tr></table></figure>
<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<p>以特定格式显示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">image</span> <span class="string">ls</span> <span class="string">--format</span> <span class="string">"<span class="template-variable">&#123;&#123;.ID&#125;&#125;</span>: <span class="template-variable">&#123;&#123;.Repository&#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">93fd78260bd1:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">93fd78260bd1:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">4ab4c602aa5e:</span> <span class="string">hello-world</span></span><br><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">image</span> <span class="string">ls</span> <span class="string">--format</span> <span class="string">"table <span class="template-variable">&#123;&#123;.ID&#125;&#125;</span>\t<span class="template-variable">&#123;&#123;.Repository&#125;&#125;</span>\t<span class="template-variable">&#123;&#123;.Tag&#125;&#125;</span>"</span></span><br><span class="line"><span class="string">IMAGE</span> <span class="string">ID</span>            <span class="string">REPOSITORY</span>          <span class="string">TAG</span></span><br><span class="line"><span class="string">93fd78260bd1</span>        <span class="string">ubuntu</span>              <span class="number">18.04</span></span><br><span class="line"><span class="string">93fd78260bd1</span>        <span class="string">ubuntu</span>              <span class="string">latest</span></span><br><span class="line"><span class="string">4ab4c602aa5e</span>        <span class="string">hello-world</span>         <span class="string">latest</span></span><br></pre></td></tr></table></figure>

<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像<span class="number">1</span>&gt; [&lt;镜像<span class="number">2</span>&gt; ...]</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<h2 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h2><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是<code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。</p>
<p>除了镜像依赖以外，还需要注意的是<strong>容器对镜像的依赖</strong>。<strong>如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像</strong>。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<h2 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h2><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。</p>
<p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ docker run --name webserver -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure>
<p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 webserver，并且映射了 <code>80</code> 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p>
<p>用浏览器访问的话，我们会看到默认的 <code>Nginx</code> 欢迎页面内容：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Welcome <span class="keyword">to</span> nginx!</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you see this page, the nginx web<span class="built_in"> server </span>is successfully installed <span class="keyword">and</span> working. Further configuration is required.</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> online documentation <span class="keyword">and</span> support please refer <span class="keyword">to</span> nginx.org.</span><br><span class="line"> Commercial support is available at nginx.com.</span><br><span class="line"></span><br><span class="line">Thank you <span class="keyword">for</span> using nginx.</span><br></pre></td></tr></table></figure>

<p>如果我们想要修改欢迎页面的内容，可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker exec -it webserver bash</span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root<span class="variable">@3729b97e8226</span><span class="symbol">:/</span><span class="comment"># exit</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p>
<p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 /usr/share/nginx/html/index.html 的内容。现在我们再刷新浏览器的话，会发现内容被改变了。</p>
<p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">$ docker diff webserver</span><br><span class="line">C /usr</span><br><span class="line">C <span class="meta-keyword">/usr/</span>share</span><br><span class="line">C <span class="meta-keyword">/usr/</span>share/nginx</span><br><span class="line">C <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/nginx/</span>html</span><br><span class="line">C <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/nginx/</span>html/index.html</span><br><span class="line">C /root</span><br><span class="line">A <span class="meta-keyword">/root/</span>.bash_history</span><br><span class="line">C /var</span><br><span class="line">C <span class="meta-keyword">/var/</span>cache</span><br><span class="line">C <span class="meta-keyword">/var/</span>cache/nginx</span><br><span class="line">A <span class="meta-keyword">/var/</span>cache<span class="meta-keyword">/nginx/</span>scgi_temp</span><br><span class="line">A <span class="meta-keyword">/var/</span>cache<span class="meta-keyword">/nginx/</span>uwsgi_temp</span><br><span class="line">A <span class="meta-keyword">/var/</span>cache<span class="meta-keyword">/nginx/</span>client_temp</span><br><span class="line">A <span class="meta-keyword">/var/</span>cache<span class="meta-keyword">/nginx/</span>fastcgi_temp</span><br><span class="line">A <span class="meta-keyword">/var/</span>cache<span class="meta-keyword">/nginx/</span>proxy_temp</span><br><span class="line">C /run</span><br><span class="line">A <span class="meta-keyword">/run/</span>nginx.pid</span><br></pre></td></tr></table></figure>
<p>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。</p>
<p>docker commit 的语法格式为：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; <span class="meta">[&lt;仓库名&gt;[:&lt;标签&gt;]</span>]</span><br></pre></td></tr></table></figure>

<p>我们可以用下面的命令将容器保存为镜像：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line">$ <span class="string">docker </span><span class="string">commit </span><span class="built_in">--author</span> <span class="string">"chuxing"</span> <span class="built_in">--message</span> <span class="string">"update page"</span> <span class="string">webserver </span><span class="string">nginx:v2</span></span><br><span class="line"><span class="string">sha256:</span><span class="string">8aaa0b63a1b842fb301d5d691cae92d9fdb52c73f37858eefada4325a36474f0</span></span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ docker image ls nginx</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">nginx               v2                  <span class="number">8</span>aaa0b63a1b8        About a minute ago   <span class="number">109</span>MB</span><br><span class="line">nginx               latest              <span class="number">568</span>c4670fa80        <span class="number">4</span> weeks ago          <span class="number">109</span>MB</span><br></pre></td></tr></table></figure>

<p>新的镜像定制好后，我们可以运行这个镜像:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run --name web2 -d -p <span class="number">81</span>:<span class="number">80</span> nginx:v2</span><br></pre></td></tr></table></figure>
<h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<ol>
<li>如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</li>
<li>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。</li>
<li>回顾之前提及的镜像所使用的分层存储的概念，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，每一次修改都会让镜像更加臃肿一次，这会让镜像更加臃肿。</li>
</ol>
<h2 id="镜像导入和导出"><a href="#镜像导入和导出" class="headerlink" title="镜像导入和导出"></a>镜像导入和导出</h2><h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker save -o nginx.tar <span class="symbol">nginx:</span>latest</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker save &gt; nginx.tar <span class="symbol">nginx:</span>latest</span><br></pre></td></tr></table></figure>


<h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker load -i nginx.tar</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>docker load &lt; nginx.tar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS安装docker</title>
    <url>/2020/01/30/CentOS-install-docker/</url>
    <content><![CDATA[<h3 id="1-移除旧的版本"><a href="#1-移除旧的版本" class="headerlink" title="1. 移除旧的版本"></a>1. 移除旧的版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="2-安装一些必要的系统工具"><a href="#2-安装一些必要的系统工具" class="headerlink" title="2. 安装一些必要的系统工具"></a>2. 安装一些必要的系统工具</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<h3 id="3-添加软件源信息"><a href="#3-添加软件源信息" class="headerlink" title="3. 添加软件源信息"></a>3. 添加软件源信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h3 id="4-更新-yum-缓存"><a href="#4-更新-yum-缓存" class="headerlink" title="4. 更新 yum 缓存"></a>4. 更新 yum 缓存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>

<h3 id="5-安装-Docker-ce"><a href="#5-安装-Docker-ce" class="headerlink" title="5. 安装 Docker-ce"></a>5. 安装 Docker-ce</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="6-启动-Docker-后台服务"><a href="#6-启动-Docker-后台服务" class="headerlink" title="6. 启动 Docker 后台服务"></a>6. 启动 Docker 后台服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="7-测试运行-hello-world"><a href="#7-测试运行-hello-world" class="headerlink" title="7. 测试运行 hello-world"></a>7. 测试运行 hello-world</h3><p>初次运行可能会报如下的错误信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos ~]# docker run hello-world</span><br><span class="line">Unable to find image 'hello-world:latest' locally</span><br><span class="line">docker: Error response from daemon: Get https://registry-1.docker.io/v2/library/hello-world/manifests/latest: Get https://auth.docker.io/token?scope=repository%3Alibrary%2Fhello-world%3Apull&amp;service=registry.docker.io: net/http: TLS handshake timeout.</span><br><span class="line">See 'docker run --help'.</span><br></pre></td></tr></table></figure>
<p>解决方式是使用国内的镜像地址，新建<code>/etc/docker/daemon.json</code>文件，填写如下配置信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后运行正常，如下：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">[root@VM_0_6_centos docker]<span class="comment"># docker run hello-world</span></span><br><span class="line">Unable <span class="keyword">to</span> find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:<span class="number">0add</span>3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello <span class="keyword">from</span> Docker!</span><br><span class="line">This message shows <span class="literal">that</span> your installation appears <span class="keyword">to</span> be working correctly.</span><br><span class="line"></span><br><span class="line">To generate <span class="keyword">this</span> message, Docker took the following steps:</span><br><span class="line"> <span class="number">1.</span> The Docker client contacted the Docker daemon.</span><br><span class="line"> <span class="number">2.</span> The Docker daemon pulled the <span class="string">"hello-world"</span> image <span class="keyword">from</span> the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> <span class="number">3.</span> The Docker daemon created a <span class="keyword">new</span> container <span class="keyword">from</span> <span class="literal">that</span> image which runs the</span><br><span class="line">    executable <span class="literal">that</span> produces the output you are currently reading.</span><br><span class="line"> <span class="number">4.</span> The Docker daemon streamed <span class="literal">that</span> output <span class="keyword">to</span> the Docker client, which sent <span class="literal">it</span></span><br><span class="line">    <span class="keyword">to</span> your terminal.</span><br><span class="line"></span><br><span class="line">To <span class="keyword">try</span> something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -<span class="literal">it</span> ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, <span class="keyword">and</span> more <span class="keyword">with</span> a free Docker ID:</span><br><span class="line"> https:<span class="regexp">//hub.docker.com/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">For more examples and ideas, visit:</span></span><br><span class="line"><span class="regexp"> https://</span>docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SO_REUSEADDR &amp; SO_REUSEPORT</title>
    <url>/2020/01/30/SO-REUSEADDR-SO-REUSEPORT/</url>
    <content><![CDATA[<p><strong>SO_REUSEADDR</strong></p>
<ol>
<li>当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。</li>
<li>SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可<br>以测试这种情况。</li>
<li>SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。</li>
<li>SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</li>
</ol>
<a id="more"></a>

<p><strong>SO_REUSEPORT</strong></p>
<blockquote>
<p>The new socket option allows multiple sockets on the same host to bind to the same port, and is intended to improve the performance of multithreaded network server applications running on top of multicore systems.</p>
</blockquote>
<p>linux kernel 3.9引入了最新的SO_REUSEPORT选项，使得多进程或者多线程可以创建多个绑定同一个ip:port的监听socket，提高服务器的接收连接的并发能力,程序的扩展性更好；此时需要设置SO_REUSEPORT（注意所有进程都要设置才生效）。</p>
<p>目的：每一个进程有一个独立的监听socket，并且bind相同的ip:port，独立的listen()和accept()；提高接收连接的能力。（例如nginx多进程同时监听同一个ip:port）</p>
<p>解决的问题：</p>
<ul>
<li>避免了应用层多线程或者进程监听同一ip:port的“惊群效应”。</li>
<li>内核层面实现负载均衡，保证每个进程或者线程接收均衡的连接数。</li>
<li>只有effective-user-id相同的服务器进程才能监听同一ip:port （安全性考虑）</li>
</ul>
<p>golang开源实现：<a href="https://github.com/kavu/go_reuseport" target="_blank" rel="noopener">https://github.com/kavu/go_reuseport</a></p>
<p>注意：SO_REUSEPORT只支持TCP和UDP。对unix domain socket不生效。</p>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>REUSEADDR</tag>
        <tag>REUSEPORT</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes概述</title>
    <url>/2020/01/29/Introduction-of-K8S/</url>
    <content><![CDATA[<h1 id="Kubernetes-简介"><a href="#Kubernetes-简介" class="headerlink" title="Kubernetes 简介"></a>Kubernetes 简介</h1><p>Kubernetes 是谷歌开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，主要功能包括：</p>
<ul>
<li>基于容器的应用部署、维护和滚动升级</li>
<li>负载均衡和服务发现</li>
<li>跨机器和跨地区的集群调度</li>
<li>自动伸缩</li>
<li>无状态服务和有状态服务</li>
<li>广泛的 Volume 支持</li>
<li>插件机制保证扩展性</li>
</ul>
<a id="more"></a>

<h2 id="Kubernetes-是一个平台"><a href="#Kubernetes-是一个平台" class="headerlink" title="Kubernetes 是一个平台"></a>Kubernetes 是一个平台</h2><p>Kubernetes 提供了很多的功能，它可以简化应用程序的工作流，加快开发速度。</p>
<ul>
<li>用户可以使用 Label 以自己的方式组织管理资源，还可以使用 Annotation 来自定义资源的描述信息，比如为管理工具提供状态检查等。</li>
<li>Kubernetes 控制器也是构建在跟开发人员和用户使用的相同的 API 之上。用户还可以编写自己的控制器和调度器，也可以通过各种插件机制扩展系统的功能。</li>
</ul>
<h2 id="Kubernetes-不是什么"><a href="#Kubernetes-不是什么" class="headerlink" title="Kubernetes 不是什么"></a>Kubernetes 不是什么</h2><p>Kubernetes 不是一个传统意义上，包罗万象的 PaaS (平台即服务) 系统，它给用户保留了选择的自由和灵活性。</p>
<ul>
<li>不限制支持的应用程序类型。Kubernetes 旨在支持极其多样化的工作负载，包括无状态、有状态和数据处理工作负载。只要应用可以在容器中运行，那么它就可以很好的在 Kubernetes 上运行。</li>
<li>不提供内置的中间件 (如消息中间件)、数据处理框架 (如 Spark)、数据库 (如 mysql) 或集群存储系统 (如 Ceph) 等。</li>
<li>不直接部署代码，也不会构建您的应用程序。</li>
<li>允许用户选择自己的日志、监控和告警系统。</li>
<li>不提供应用程序配置语言或系统 (如 jsonnet)。</li>
<li>不提供机器配置、维护、管理或自愈系统。</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>Kubernetes 主要由以下几个核心组件组成：</p>
<ul>
<li>etcd 保存了整个集群的状态；</li>
<li>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li>
<li>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li>
<li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；</li>
<li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；</li>
<li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡<br><img src="https://img-blog.csdnimg.cn/20191118230100546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="k8s核心组件"><h1 id="Kubernetes-基本概念"><a href="#Kubernetes-基本概念" class="headerlink" title="Kubernetes 基本概念"></a>Kubernetes 基本概念</h1><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2>Container（容器）是一种便携式、轻量级的操作系统级虚拟化技术。它使用 namespace 隔离不同的软件运行环境，并通过镜像自包含软件的运行环境，从而使得容器可以很方便的在任何地方运行。</li>
</ul>
<p>使用容器，不需要与外部的基础架构环境绑定，因为每一个应用程序都不需要外部依赖，更不需要与外部的基础架构环境依赖。完美解决了从开发到生产环境的一致性问题。</p>
<p>容器同样比虚拟机更加透明，这有助于监测和管理。尤其是容器进程的生命周期由基础设施管理，而不是被进程管理器隐藏在容器内部。最后，每个应用程序用容器封装，管理容器部署就等同于管理应用程序部署。</p>
<p>容器的其他优点：</p>
<ul>
<li>敏捷的应用程序创建和部署：与虚拟机镜像相比，容器镜像更易用、更高效。</li>
<li>持续开发、集成和部署：提供可靠与频繁的容器镜像构建、部署和快速简便的回滚（镜像是不可变的）。</li>
<li>开发与运维的关注分离：在构建/发布时即创建容器镜像，从而将应用与基础架构分离。</li>
<li>开发、测试与生产环境的一致性：在笔记本电脑上运行和云中一样。</li>
<li>可观测：不仅显示操作系统的信息和度量，还显示应用自身的信息和度量。</li>
<li>云和操作系统的分发可移植性：可运行在 Ubuntu, RHEL, CoreOS, 物理机, GKE 以及其他任何地方。</li>
<li>以应用为中心的管理：从传统的硬件上部署操作系统提升到操作系统中部署应用程序。</li>
<li>松耦合、分布式、弹性伸缩、微服务：应用程序被分成更小，更独立的模块，并可以动态管理和部署。</li>
<li>资源隔离：可预测的应用程序性能。</li>
<li>资源利用：高效率和高密度。</li>
</ul>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Kubernetes 使用 Pod 来管理容器，每个 Pod 可以包含一个或多个紧密关联的容器。</p>
<p>Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace，是 Kubernetes 调度的基本单位。Pod 内的多个容器共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p>
<p>在 Kubernetes 中，所有对象都使用 manifest（yaml 或 json）来定义，比如一个简单的 nginx 服务可以定义为 nginx.yaml，它包含一个镜像为 nginx 的容器：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是 Pod 真正运行的主机，可以是物理机，也可以是虚拟机。为了管理 Pod，每个 Node 节点上至少要运行 container runtime（比如 docker 或者 rkt）、kubelet 和 kube-proxy 服务。</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 namespace 的（默认是 default），而 node, persistentVolumes 等则不属于任何 namespace。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的 Pod IP 和端口列表组成 endpoints，由 kube-proxy 负责将服务 IP 负载均衡到这些 endpoints 上。<br>每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。<br><img src="https://img-blog.csdnimg.cn/20191118230137955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="k8s-service"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8078</span> <span class="comment"># the port that this service should serve on</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="comment"># the container on each pod to connect to, can be a name</span></span><br><span class="line">    <span class="comment"># (e.g. 'www') or a number (e.g. 80)</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>Label 是识别 Kubernetes 对象的标签，以 key/value 的方式附加到对象上（key 最长不能超过 63 字节，value 可以为空，也可以是不超过 253 字节的字符串）。</p>
<p>Label 不提供唯一性，并且实际上经常是很多对象（如 Pods）都使用相同的 label 来标志具体的应用。<br>Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象（比如 ReplicaSet 和 Service 用 label 来选择一组 Pod）。Label Selector 支持以下几种方式：</p>
<ul>
<li>等式，如 app=nginx 和 env!=production</li>
<li>集合，如 env in (production, qa)</li>
<li>多个 label（它们之间是 AND 关系），如 app=nginx,env=test</li>
</ul>
<h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><p>Annotations 是 key/value 形式附加于对象的注解。不同于 Labels 用于标志和选择对象，Annotations 则是用来记录一些附加信息，用来辅助应用部署、安全策略以及调度策略等。比如 deployment 使用 annotations 来记录 rolling update 的状态。</p>
<p>参考来源：</p>
<ol>
<li><a href="https://feisky.gitbooks.io/kubernetes/introduction/" target="_blank" rel="noopener">https://feisky.gitbooks.io/kubernetes/introduction/</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生概述</title>
    <url>/2020/01/28/Introduction-of-Cloud-Native/</url>
    <content><![CDATA[<h1 id="云原生的定义"><a href="#云原生的定义" class="headerlink" title="云原生的定义"></a>云原生的定义</h1><p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。</p>
<p>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p>
<a id="more"></a>

<h1 id="云原生的设计哲学"><a href="#云原生的设计哲学" class="headerlink" title="云原生的设计哲学"></a>云原生的设计哲学</h1><p>云原生本身甚至不能称为是一种架构，它首先是一种基础设施，运行在其上的应用称作云原生应用，只有符合云原生设计哲学的应用架构才叫云原生应用架构。</p>
<h2 id="云原生的设计理念"><a href="#云原生的设计理念" class="headerlink" title="云原生的设计理念"></a>云原生的设计理念</h2><p>云原生系统的设计理念如下:</p>
<ul>
<li>面向分布式设计（Distribution）：容器、微服务、API 驱动的开发；</li>
<li>面向配置设计（Configuration）：一个镜像，多个环境配置；</li>
<li>面向韧性设计（Resistancy）：故障容忍和自愈；</li>
<li>面向弹性设计（Elasticity）：弹性扩展和对环境变化（负载）做出响应；</li>
<li>面向交付设计（Delivery）：自动拉起，缩短交付时间；</li>
<li>面向性能设计（Performance）：响应式，并发和资源高效利用；</li>
<li>面向自动化设计（Automation）：自动化的 DevOps；</li>
<li>面向诊断性设计（Diagnosability）：集群级别的日志、metric 和追踪；</li>
<li>面向安全性设计（Security）：安全端点、API Gateway、端到端加密；</li>
</ul>
<h2 id="云原生应用程序"><a href="#云原生应用程序" class="headerlink" title="云原生应用程序"></a>云原生应用程序</h2><p>云原生应用程序被设计为在平台上运行，并设计用于弹性，敏捷性，可操作性和可观察性。弹性包含失败而不是试图阻止它们；它利用了在平台上运行的动态特性。敏捷性允许快速部署和快速迭代。可操作性从应用程序内部控制应用程序生命周期，而不是依赖外部进程和监视器。可观察性提供信息来回答有关应用程序状态的问题。</p>
<p>实现云原生应用程序所需特性的常用方法：</p>
<ul>
<li>微服务</li>
<li>健康报告</li>
<li>遥测数据</li>
<li>弹性</li>
<li>声明式的，而不是命令式的</li>
</ul>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>微服务 (Microservices) 是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent/Language agnostic) 的 API 集相互通信。</p>
<p>微服务是一种以业务功能为主的服务设计概念，每一个服务都具有自主运行的业务功能，对外开放不受语言限制的 API (最常用的是 HTTP)，应用程序则是由一个或多个微服务组成。</p>
<h3 id="健康报告"><a href="#健康报告" class="headerlink" title="健康报告"></a>健康报告</h3><p>为了提高云原生应用程序的可操作性，应用程序应该暴露健康检查。开发人员可以将其实施为命令或过程信号，以便应用程序在执行自我检查之后响应，或者更常见的是：通过应用程序提供Web服务，返回HTTP状态码来检查健康状态。</p>
<p>一个很好的例子就是当平台需要知道应用程序何时可以接收流量。在应用程序启动时，如果它不能正确处理流量，它就应该表现为未准备好。</p>
<h3 id="遥测数据"><a href="#遥测数据" class="headerlink" title="遥测数据"></a>遥测数据</h3><p>遥测数据是进行决策所需的信息。确实，遥测数据可能与健康报告重叠，但它们有不同的用途。健康报告通知我们应用程序生命周期状态，而遥测数据通知我们应用程序业务目标。</p>
<p>测量的指标有时称为服务级指标（SLI）或关键性能指标（KPI）。这些是特定于应用程序的数据，可以确保应用程序的性能处于服务级别目标（SLO）内。</p>
<h3 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h3><p>一旦你有遥测和监测数据，你需要确保你的应用程序对故障有适应能力。弹性是基础设施的责任，但云原生应用程序也需要承担部分工作。在云原生应用程序中考虑弹性的两个主要方面：为失败设计和优雅降级。</p>
<h4 id="为失败设计"><a href="#为失败设计" class="headerlink" title="为失败设计"></a>为失败设计</h4><p>设计一个以失败期望为目标的应用程序将比假定可用性的应用程序更具防御性。当故障不可避免时，将会有额外的检查，故障模式和日志内置到应用程序中。</p>
<h4 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h4><p>云原生应用程序处理过载的一种方式。</p>
<h3 id="声明式，非命令式"><a href="#声明式，非命令式" class="headerlink" title="声明式，非命令式"></a>声明式，非命令式</h3><p>声明式编程是一种编程范式，与命令式编程相对立。它描述目标的性质，让电脑明白目标，而非流程。声明式编程不用告诉电脑问题领域，从而避免随之而来的副作用。而命令式编程则需要用算法来明确的指出每一步该怎么做。</p>
<p>声明式通信模型规范了通信模型，并且它将功能实现从应用程序转移到远程API或服务端点，从而实现某种状态到达期望状态。这有助于简化应用程序，并使它们彼此的行为更具可预测性。</p>
<p>例子：SQL数据库<br>其实你很早就接触过声明式编程语言， SQL语言就是很典型的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> user_name = Ben</span><br></pre></td></tr></table></figure>
<p>上面是一个很普通的SQL查询语句，我只只声明我想要找一个叫Ben的用户（What) , 就是不说SQL该怎么（How）去寻找怎么做。接下来我们看看如果用命令式语言写会是什么样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user=[&#123;user_name:'ou',user_id=1&#125;,.....]</span></span><br><span class="line"><span class="keyword">var</span> user</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; user.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(user.user_name == <span class="string">"Ben"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         print(<span class="string">"find"</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的对比你可以看出声明式语言的优势-短小精悍，你并不会知道程序的控制流（control flow）我们不需要告诉程序如何去寻找（How），而是只告诉程序我们想要的结果（What），让程序自己来解决过程（How）。当然SQL具体的细节还是用命令式的编程风格来实现的。</p>
<h1 id="Play-with-Kubernetes"><a href="#Play-with-Kubernetes" class="headerlink" title="Play with Kubernetes"></a>Play with Kubernetes</h1><h2 id="创建Kubernetes集群"><a href="#创建Kubernetes集群" class="headerlink" title="创建Kubernetes集群"></a>创建Kubernetes集群</h2><p>登陆Play with Kubernetes，启动第一个实例作为Master节点，在web终端上执行：</p>
<ol>
<li><p>初始化master节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address $(hostname -i)</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">[node1 ~]$ kubeadm init --apiserver-advertise-address $(hostname -i)</span><br><span class="line">Initializing machine ID from random generator.</span><br><span class="line">[init] using Kubernetes version: v1<span class="number">.11</span><span class="number">.10</span></span><br><span class="line">[preflight] running pre-flight checks</span><br><span class="line">        [WARNING Service-Docker]: docker service is not active, please run 'systemctl start docker.service'</span><br><span class="line">        [WARNING FileContent--<span class="keyword">proc</span>-sys-net-bridge-bridge-nf-call-iptables]: /<span class="keyword">proc</span>/sys/net/bridge/bridge-nf-call-iptables<span class="title"> does</span> not<span class="title"> exist</span></span><br><span class="line"><span class="title">I1117</span> 13:53:18.409493     885<span class="title"> kernel_validator.go:81]</span> Validating<span class="title"> kernel</span> version</span><br><span class="line">I1117 13:53:18.409685     885<span class="title"> kernel_validator.go:96]</span> Validating<span class="title"> kernel</span> config</span><br><span class="line">[preflight]<span class="title"> The</span> system<span class="title"> verification</span> failed.<span class="title"> Printing</span> the<span class="title"> output</span> from<span class="title"> the</span> verification:</span><br><span class="line">KERNEL_VERSION: 4.4.0-148-generic</span><br><span class="line">DOCKER_VERSION: 18.06.1-ce</span><br><span class="line">OS:<span class="title"> Linux</span></span><br><span class="line"><span class="title">CGROUPS_CPU:</span> enabled</span><br><span class="line">CGROUPS_CPUACCT:<span class="title"> enabled</span></span><br><span class="line"><span class="title">CGROUPS_CPUSET:</span> enabled</span><br><span class="line">CGROUPS_DEVICES:<span class="title"> enabled</span></span><br><span class="line"><span class="title">CGROUPS_FREEZER:</span> enabled</span><br><span class="line">CGROUPS_MEMORY:<span class="title"> enabled</span></span><br><span class="line"><span class="title"></span>        [WARNING<span class="title"> SystemVerification]:</span> docker<span class="title"> version</span> is<span class="title"> greater</span> than<span class="title"> the</span> most<span class="title"> recently</span> validated<span class="title"> version.</span> Docker<span class="title"> version:</span> 18.06.1-ce.<span class="title"> Max</span> validated<span class="title"> version:</span> 17.03</span><br><span class="line">        [WARNING<span class="title"> SystemVerification]:</span> failed<span class="title"> to</span> parse<span class="title"> kernel</span> config:<span class="title"> unable</span> to<span class="title"> load</span> kernel<span class="title"> module</span> "configs":<span class="title"> output</span> - "",<span class="title"> err</span> -<span class="title"> exit</span> status 1</span><br><span class="line"></span><br><span class="line">[preflight/images]<span class="title"> Pulling</span> images<span class="title"> required</span> for<span class="title"> setting</span> up<span class="title"> a</span> Kubernetes<span class="title"> cluster</span></span><br><span class="line"><span class="title">[preflight/images]</span> This<span class="title"> might</span> take<span class="title"> a</span> minute<span class="title"> or</span> two,<span class="title"> depending</span> on<span class="title"> the</span> speed<span class="title"> of</span> your<span class="title"> internet</span> connection</span><br><span class="line">[preflight/images]<span class="title"> You</span> can<span class="title"> also</span> perform<span class="title"> this</span> action<span class="title"> in</span> beforehand<span class="title"> using</span> 'kubeadm<span class="title"> config</span> images<span class="title"> pull'</span></span><br><span class="line"><span class="title">[kubelet]</span> Writing<span class="title"> kubelet</span> environment<span class="title"> file</span> with<span class="title"> flags</span> to<span class="title"> file</span> "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet]<span class="title"> Writing</span> kubelet<span class="title"> configuration</span> to<span class="title"> file</span> "/var/lib/kubelet/config.yaml"</span><br><span class="line">[preflight]<span class="title"> Activating</span> the<span class="title"> kubelet</span> service</span><br><span class="line">[certificates]<span class="title"> Generated</span> ca<span class="title"> certificate</span> and<span class="title"> key.</span></span><br><span class="line"><span class="title">[certificates]</span> Generated<span class="title"> apiserver</span> certificate<span class="title"> and</span> key.</span><br><span class="line">[certificates]<span class="title"> apiserver</span> serving<span class="title"> cert</span> is<span class="title"> signed</span> for<span class="title"> DNS</span> names [node1<span class="title"> kubernetes</span> kubernetes.default<span class="title"> kubernetes.default.svc</span> kubernetes.default.svc.cluster.local]<span class="title"> and</span> IPs [10.96.0.1 192.168.0.18]</span><br><span class="line">[certificates]<span class="title"> Generated</span> apiserver-kubelet-client<span class="title"> certificate</span> and<span class="title"> key.</span></span><br><span class="line"><span class="title">[certificates]</span> Generated<span class="title"> sa</span> key<span class="title"> and</span> public<span class="title"> key.</span></span><br><span class="line"><span class="title">[certificates]</span> Generated<span class="title"> front-proxy-ca</span> certificate<span class="title"> and</span> key.</span><br><span class="line">[certificates]<span class="title"> Generated</span> front-proxy-client<span class="title"> certificate</span> and<span class="title"> key.</span></span><br><span class="line"><span class="title">[certificates]</span> Generated<span class="title"> etcd/ca</span> certificate<span class="title"> and</span> key.</span><br><span class="line">[certificates]<span class="title"> Generated</span> etcd/server<span class="title"> certificate</span> and<span class="title"> key.</span></span><br><span class="line"><span class="title">[certificates]</span> etcd/server<span class="title"> serving</span> cert<span class="title"> is</span> signed<span class="title"> for</span> DNS<span class="title"> names</span> [node1<span class="title"> localhost]</span> and<span class="title"> IPs</span> [127.0.0.1 ::1]</span><br><span class="line">[certificates]<span class="title"> Generated</span> etcd/peer<span class="title"> certificate</span> and<span class="title"> key.</span></span><br><span class="line"><span class="title">[certificates]</span> etcd/peer<span class="title"> serving</span> cert<span class="title"> is</span> signed<span class="title"> for</span> DNS<span class="title"> names</span> [node1<span class="title"> localhost]</span> and<span class="title"> IPs</span> [192.168.0.18 127.0.0.1 ::1]</span><br><span class="line">[certificates]<span class="title"> Generated</span> etcd/healthcheck-client<span class="title"> certificate</span> and<span class="title"> key.</span></span><br><span class="line"><span class="title">[certificates]</span> Generated<span class="title"> apiserver-etcd-client</span> certificate<span class="title"> and</span> key.</span><br><span class="line">[certificates]<span class="title"> valid</span> certificates<span class="title"> and</span> keys<span class="title"> now</span> exist<span class="title"> in</span> "/etc/kubernetes/pki"</span><br><span class="line">[kubeconfig]<span class="title"> Wrote</span> KubeConfig<span class="title"> file</span> to<span class="title"> disk:</span> "/etc/kubernetes/admin.conf"</span><br><span class="line">[kubeconfig]<span class="title"> Wrote</span> KubeConfig<span class="title"> file</span> to<span class="title"> disk:</span> "/etc/kubernetes/kubelet.conf"</span><br><span class="line">[kubeconfig]<span class="title"> Wrote</span> KubeConfig<span class="title"> file</span> to<span class="title"> disk:</span> "/etc/kubernetes/controller-manager.conf"</span><br><span class="line">[kubeconfig]<span class="title"> Wrote</span> KubeConfig<span class="title"> file</span> to<span class="title"> disk:</span> "/etc/kubernetes/scheduler.conf"</span><br><span class="line">[controlplane]<span class="title"> wrote</span> Static<span class="title"> Pod</span> manifest<span class="title"> for</span> component<span class="title"> kube-apiserver</span> to "/etc/kubernetes/manifests/kube-apiserver.yaml"</span><br><span class="line">[controlplane]<span class="title"> wrote</span> Static<span class="title"> Pod</span> manifest<span class="title"> for</span> component<span class="title"> kube-controller-manager</span> to "/etc/kubernetes/manifests/kube-controller-manager.yaml"</span><br><span class="line">[controlplane]<span class="title"> wrote</span> Static<span class="title"> Pod</span> manifest<span class="title"> for</span> component<span class="title"> kube-scheduler</span> to "/etc/kubernetes/manifests/kube-scheduler.yaml"</span><br><span class="line">[etcd]<span class="title"> Wrote</span> Static<span class="title"> Pod</span> manifest<span class="title"> for</span> a<span class="title"> local</span> etcd<span class="title"> instance</span> to "/etc/kubernetes/manifests/etcd.yaml"</span><br><span class="line">[init]<span class="title"> waiting</span> for<span class="title"> the</span> kubelet<span class="title"> to</span> boot<span class="title"> up</span> the<span class="title"> control</span> plane<span class="title"> as</span> Static<span class="title"> Pods</span> from<span class="title"> directory</span> "/etc/kubernetes/manifests"</span><br><span class="line">[init]<span class="title"> this</span> might<span class="title"> take</span> a<span class="title"> minute</span> or<span class="title"> longer</span> if<span class="title"> the</span> control<span class="title"> plane</span> images<span class="title"> have</span> to<span class="title"> be</span> pulled</span><br><span class="line">[apiclient]<span class="title"> All</span> control<span class="title"> plane</span> components<span class="title"> are</span> healthy<span class="title"> after</span> 51.503514<span class="title"> seconds</span></span><br><span class="line"><span class="title">[uploadconfig]</span> storing<span class="title"> the</span> configuration<span class="title"> used</span> in<span class="title"> ConfigMap</span> "kubeadm-config"<span class="title"> in</span> the "kube-system"<span class="title"> Namespace</span></span><br><span class="line"><span class="title">[kubelet]</span> Creating<span class="title"> a</span> ConfigMap "kubelet-config-1.11"<span class="title"> in</span> namespace<span class="title"> kube-system</span> with<span class="title"> the</span> configuration<span class="title"> for</span> the<span class="title"> kubelets</span> in<span class="title"> the</span> cluster</span><br><span class="line">[markmaster]<span class="title"> Marking</span> the<span class="title"> node</span> node1<span class="title"> as</span> master<span class="title"> by</span> adding<span class="title"> the</span> label "node-role.kubernetes.io/master=''"</span><br><span class="line">[markmaster]<span class="title"> Marking</span> the<span class="title"> node</span> node1<span class="title"> as</span> master<span class="title"> by</span> adding<span class="title"> the</span> taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[patchnode]<span class="title"> Uploading</span> the<span class="title"> CRI</span> Socket<span class="title"> information</span> "/var/run/dockershim.sock"<span class="title"> to</span> the<span class="title"> Node</span> API<span class="title"> object</span> "node1"<span class="title"> as</span> an<span class="title"> annotation</span></span><br><span class="line"><span class="title">[bootstraptoken]</span> using<span class="title"> token:</span> 5f1nyz.351cet8vt4g2ix78</span><br><span class="line">[bootstraptoken]<span class="title"> configured</span> RBAC<span class="title"> rules</span> to<span class="title"> allow</span> Node<span class="title"> Bootstrap</span> tokens<span class="title"> to</span> post<span class="title"> CSRs</span> in<span class="title"> order</span> for<span class="title"> nodes</span> to<span class="title"> get</span> long<span class="title"> term</span> certificate<span class="title"> credentials</span></span><br><span class="line"><span class="title">[bootstraptoken]</span> configured<span class="title"> RBAC</span> rules<span class="title"> to</span> allow<span class="title"> the</span> csrapprover<span class="title"> controller</span> automatically<span class="title"> approve</span> CSRs<span class="title"> from</span> a<span class="title"> Node</span> Bootstrap<span class="title"> Token</span></span><br><span class="line"><span class="title">[bootstraptoken]</span> configured<span class="title"> RBAC</span> rules<span class="title"> to</span> allow<span class="title"> certificate</span> rotation<span class="title"> for</span> all<span class="title"> node</span> client<span class="title"> certificates</span> in<span class="title"> the</span> cluster</span><br><span class="line">[bootstraptoken]<span class="title"> creating</span> the "cluster-info"<span class="title"> ConfigMap</span> in<span class="title"> the</span> "kube-public"<span class="title"> namespace</span></span><br><span class="line"><span class="title">[addons]</span> Applied<span class="title"> essential</span> addon:<span class="title"> CoreDNS</span></span><br><span class="line"><span class="title">[addons]</span> Applied<span class="title"> essential</span> addon:<span class="title"> kube-proxy</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Your</span> Kubernetes<span class="title"> master</span> has<span class="title"> initialized</span> successfully!</span><br><span class="line"></span><br><span class="line">To<span class="title"> start</span> using<span class="title"> your</span> cluster,<span class="title"> you</span> need<span class="title"> to</span> run<span class="title"> the</span> following<span class="title"> as</span> a<span class="title"> regular</span> user:</span><br><span class="line"></span><br><span class="line"><span class="title">  mkdir</span> -p $HOME/.kube</span><br><span class="line"><span class="title">  sudo</span> cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line"><span class="title">  sudo</span> chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You<span class="title"> should</span> now<span class="title"> deploy</span> a<span class="title"> pod</span> network<span class="title"> to</span> the<span class="title"> cluster.</span></span><br><span class="line"><span class="title">Run</span> "kubectl<span class="title"> apply</span> -f [podnetwork].yaml"<span class="title"> with</span> one<span class="title"> of</span> the<span class="title"> options</span> listed<span class="title"> at:</span></span><br><span class="line"><span class="title"></span> <span class="title"> https://kubernetes.io/docs/concepts/cluster-administration/addons/</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">You</span> can<span class="title"> now</span> join<span class="title"> any</span> number<span class="title"> of</span> machines<span class="title"> by</span> running<span class="title"> the</span> following<span class="title"> on</span> each<span class="title"> node</span></span><br><span class="line"><span class="title">as</span> root:</span><br><span class="line"></span><br><span class="line"><span class="title">  kubeadm</span> join 192.168.0.18:6443 --token 5f1nyz.351cet8vt4g2ix78 --discovery-token-ca-cert-hash<span class="title"> sha256:d105d049cf090f7814473e5554b79e09cd13e4acfd8a56b09754ba9181d08fd8</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Waiting</span> for<span class="title"> api</span> server<span class="title"> to</span> startup</span><br><span class="line">Warning:<span class="title"> kubectl</span> apply<span class="title"> should</span> be<span class="title"> used</span> on<span class="title"> resource</span> created<span class="title"> by</span> either<span class="title"> kubectl</span> create --save-config<span class="title"> or</span> kubectl<span class="title"> apply</span></span><br><span class="line"><span class="title">daemonset.extensions/kube-proxy</span> configured</span><br><span class="line">No<span class="title"> resources</span> found</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化集群网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -n kube-system -f  "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">serviceaccount/weave-net created</span><br><span class="line">clusterrole<span class="selector-class">.rbac</span><span class="selector-class">.authorization</span><span class="selector-class">.k8s</span>.io/weave-net created</span><br><span class="line">clusterrolebinding<span class="selector-class">.rbac</span><span class="selector-class">.authorization</span><span class="selector-class">.k8s</span>.io/weave-net created</span><br><span class="line">role<span class="selector-class">.rbac</span><span class="selector-class">.authorization</span><span class="selector-class">.k8s</span>.io/weave-net created</span><br><span class="line">rolebinding<span class="selector-class">.rbac</span><span class="selector-class">.authorization</span><span class="selector-class">.k8s</span>.io/weave-net created</span><br><span class="line">daemonset.apps/weave-net created</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下列初始化命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure></li>
<li><p>根据master节点上的提示，在新的web终端上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 192.168.0.18:6443 --token 5f1nyz.351cet8vt4g2ix78 --discovery-token-ca-cert-hash sha256:d105d049cf090f7814473e5554b79e09cd13e4acfd8a56b09754ba9181d08fd8</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[preflight] running pre-flight checks</span><br><span class="line">        [<span class="builtin-name">WARNING</span> DirAvailable--etc-kubernetes-manifests]: /etc/kubernetes/manifests is <span class="keyword">not</span> empty</span><br><span class="line">        [<span class="builtin-name">WARNING</span> FileAvailable--etc-kubernetes-pki-ca.crt]: /etc/kubernetes/pki/ca.crt already exists</span><br><span class="line">        [<span class="builtin-name">WARNING</span> FileAvailable--etc-kubernetes-kubelet.conf]: /etc/kubernetes/kubelet.conf already exists</span><br><span class="line">        [<span class="builtin-name">WARNING</span> RequiredIPVSKernelModulesAvailable]: <span class="builtin-name">error</span> getting required builtin kernel modules: exit status 1(cut: /lib/modules/4.4.0-166-generic/modules.builtin: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line">)</span><br><span class="line">        [<span class="builtin-name">WARNING</span> Service-Docker]: docker<span class="built_in"> service </span>is <span class="keyword">not</span> active, please <span class="builtin-name">run</span> <span class="string">'systemctl start docker.service'</span></span><br><span class="line">        [<span class="builtin-name">WARNING</span> FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables does <span class="keyword">not</span> exist</span><br><span class="line">I1117 14:09:02.416363    7243 kernel_validator.go:81] Validating kernel version</span><br><span class="line">I1117 14:09:02.419283    7243 kernel_validator.go:96] Validating kernel config</span><br><span class="line">[preflight] The<span class="built_in"> system </span>verification failed. Printing the output <span class="keyword">from</span> the verification:</span><br><span class="line">KERNEL_VERSION: 4.4.0-166-generic</span><br><span class="line">DOCKER_VERSION: 18.06.1-ce</span><br><span class="line">OS: Linux</span><br><span class="line">CGROUPS_CPU: enabled</span><br><span class="line">CGROUPS_CPUACCT: enabled</span><br><span class="line">CGROUPS_CPUSET: enabled</span><br><span class="line">CGROUPS_DEVICES: enabled</span><br><span class="line">CGROUPS_FREEZER: enabled</span><br><span class="line">CGROUPS_MEMORY: enabled</span><br><span class="line">        [<span class="builtin-name">WARNING</span> SystemVerification]: docker version is greater than the most recently validated version. Docker version: 18.06.1-ce. Max validated version: 17.03</span><br><span class="line">        [<span class="builtin-name">WARNING</span> SystemVerification]: failed <span class="keyword">to</span> parse kernel config: unable <span class="keyword">to</span> load kernel module <span class="string">"configs"</span>: output - <span class="string">""</span>, err - exit status 1</span><br><span class="line">        [<span class="builtin-name">WARNING</span> Port-10250]:<span class="built_in"> Port </span>10250 is <span class="keyword">in</span> use</span><br><span class="line">[discovery] Trying <span class="keyword">to</span> connect <span class="keyword">to</span> API<span class="built_in"> Server </span><span class="string">"192.168.0.28:6443"</span></span><br><span class="line">[discovery] Created cluster-<span class="builtin-name">info</span><span class="built_in"> discovery </span>client, requesting <span class="builtin-name">info</span> <span class="keyword">from</span> <span class="string">"https://192.168.0.28:6443"</span></span><br><span class="line">[discovery] Requesting <span class="builtin-name">info</span> <span class="keyword">from</span> <span class="string">"https://192.168.0.28:6443"</span> again <span class="keyword">to</span> validate TLS against the pinned public key</span><br><span class="line">[discovery] Cluster <span class="builtin-name">info</span> signature <span class="keyword">and</span> contents are valid <span class="keyword">and</span> TLS certificate validates against pinned roots, will use API<span class="built_in"> Server </span><span class="string">"192.168.0.28:6443"</span></span><br><span class="line">[discovery] Successfully established<span class="built_in"> connection </span>with API<span class="built_in"> Server </span><span class="string">"192.168.0.28:6443"</span></span><br><span class="line">[kubelet] Downloading configuration <span class="keyword">for</span> the kubelet <span class="keyword">from</span> the <span class="string">"kubelet-config-1.11"</span> ConfigMap <span class="keyword">in</span> the kube-system namespace</span><br><span class="line">[kubelet] Writing kubelet configuration <span class="keyword">to</span> file <span class="string">"/var/lib/kubelet/config.yaml"</span></span><br><span class="line">[kubelet] Writing kubelet environment file with flags <span class="keyword">to</span> file <span class="string">"/var/lib/kubelet/kubeadm-flags.env"</span></span><br><span class="line">[preflight] Activating the kubelet service</span><br><span class="line">[tlsbootstrap] Waiting <span class="keyword">for</span> the kubelet <span class="keyword">to</span> perform the TLS Bootstrap<span class="built_in">..</span>.</span><br><span class="line">[patchnode] Uploading the CRI Socket information <span class="string">"/var/run/dockershim.sock"</span> <span class="keyword">to</span> the Node API object <span class="string">"node1"</span> as an annotation</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent <span class="keyword">to</span> master <span class="keyword">and</span> a response</span><br><span class="line">  was received.</span><br><span class="line">* The Kubelet was informed of the new secure<span class="built_in"> connection </span>details.</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">Run</span> <span class="string">'kubectl get nodes'</span> on the master <span class="keyword">to</span> see this node join the cluster.</span><br></pre></td></tr></table></figure>
<p>多开几个实例，重复执行第四步，即可向Kubernetes集群中增加节点。</p>
</li>
</ol>
<p>此时在master节点上执行<code>kubectl get nodes</code>查看节点所有节点状态：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[node1 ~]$ kubectl <span class="keyword">get</span> nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">node1     Ready     master    <span class="number">19</span>m       v1<span class="number">.11</span><span class="number">.3</span></span><br><span class="line">node2     Ready     &lt;none&gt;    <span class="number">2</span>m        v1<span class="number">.11</span><span class="number">.3</span></span><br><span class="line">node3     Ready     &lt;none&gt;    <span class="number">1</span>m        v1<span class="number">.11</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>

<h2 id="创建nginx-deployment"><a href="#创建nginx-deployment" class="headerlink" title="创建nginx deployment"></a>创建nginx deployment</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[node1 ~]$ curl https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/application/nginx-app.yaml &gt; nginx-app.yaml</span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   497  100   497    0     0   1252      0 --:--:-- --:--:-- --:--:--  1255</span><br><span class="line">[node1 ~]$</span><br><span class="line">[node1 ~]$ kubectl apply -f nginx-app.yaml</span><br><span class="line">service/my-nginx-svc created</span><br><span class="line">deployment.apps/my-nginx created</span><br></pre></td></tr></table></figure>
<p>此时查看nodes和pods：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[node1 ~]$ kubectl get nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">node1     Ready     master    29m       v1.11.3</span><br><span class="line">node2     Ready     &lt;none&gt;    11m       v1.11.3</span><br><span class="line">node3     Ready     &lt;none&gt;    11m       v1.11.3</span><br><span class="line">[node1 ~]$</span><br><span class="line">[node1 ~]$ kubectl get pods</span><br><span class="line">NAME                        READY     STATUS    RESTARTS   AGE</span><br><span class="line">my-nginx-67594d6bf6-2cbbz   1/1       Running   0          1m</span><br><span class="line">my-nginx-67594d6bf6-r2p6w   1/1       Running   0          1m</span><br><span class="line">my-nginx-67594d6bf6-vjqn4   1/1       Running   0          1m</span><br></pre></td></tr></table></figure>


<p>参考来源：</p>
<ol>
<li><a href="https://github.com/cncf/toc/blob/master/DEFINITION.md" target="_blank" rel="noopener">https://github.com/cncf/toc/blob/master/DEFINITION.md</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%AE%A3%E5%91%8A%E5%BC%8F%E7%B7%A8%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/%E5%AE%A3%E5%91%8A%E5%BC%8F%E7%B7%A8%E7%A8%8B</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34445114" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34445114</a></li>
<li><a href="https://labs.play-with-k8s.com/" target="_blank" rel="noopener">https://labs.play-with-k8s.com/</a></li>
</ol>
]]></content>
      <categories>
        <category>Cloud Native</category>
      </categories>
      <tags>
        <tag>Cloud Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Mesh概述</title>
    <url>/2020/01/28/Introduction-of-Service-Mesh/</url>
    <content><![CDATA[<h1 id="什么是服务网格？"><a href="#什么是服务网格？" class="headerlink" title="什么是服务网格？"></a>什么是服务网格？</h1><p>服务网格是用于处理服务间通信的专用基础设施层。它负责通过包含现代云原生应用程序的复杂服务拓扑来可靠地传递请求。实际上，服务网格通常通过一组轻量级网络代理来实现，这些代理与应用程序代码一起部署，而不需要感知应用程序本身。</p>
<h2 id="服务网格的特点"><a href="#服务网格的特点" class="headerlink" title="服务网格的特点"></a>服务网格的特点</h2><p>服务网格有如下几个特点：</p>
<ul>
<li>应用程序间通讯的中间层</li>
<li>轻量级网络代理</li>
<li>应用程序无感知</li>
<li>解耦应用程序的重试/超时、监控、追踪和服务发现</li>
</ul>
<a id="more"></a>

<h2 id="理解服务网格"><a href="#理解服务网格" class="headerlink" title="理解服务网格"></a>理解服务网格</h2><p>如果用一句话来解释什么是服务网格，可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控。</p>
<p>服务网格的架构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191116230107526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="Service Mesh架构图"></p>
<h2 id="为何使用服务网格？"><a href="#为何使用服务网格？" class="headerlink" title="为何使用服务网格？"></a>为何使用服务网格？</h2><p>服务网格并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在云原生的 Kubernetes 环境下的实现。</p>
<p>在传统的 MVC 三层 Web 应用程序架构下，服务之间的通讯并不复杂，在应用程序内部自己管理即可，但是在现今的复杂的大型网站情况下，单体应用被分解为众多的微服务，服务之间的依赖和通讯十分复杂，出现了 twitter 开发的 Finagle、Netflix 开发的 Hystrix 和 Google 的 Stubby 这样的 “胖客户端” 库，这些就是早期的服务网格，但是它们都仅适用于特定的环境和特定的开发语言，并不能作为平台级的服务网格支持。</p>
<p>在云原生架构下，容器的使用给予了异构应用程序的更多可行性，Kubernetes 增强的应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过多关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情而专注于程序开发，赋予开发者更多的创造性。</p>
<h1 id="服务网格架构"><a href="#服务网格架构" class="headerlink" title="服务网格架构"></a>服务网格架构</h1><p>服务网格中分为控制平面和数据平面，当前流行的两款开源的服务网格 Istio 和 Linkerd 实际上都是这种架构，只不过 Istio 的划分更清晰，而且部署更零散，很多组件都被拆分，控制平面中包括 Mixer、Pilot、Citadel，数据平面默认是用 Envoy；而 Linkerd 中只分为 Linkerd 做数据平面，namerd 作为控制平面。</p>
<p><strong>控制平面的特点</strong></p>
<ul>
<li>不直接解析数据包</li>
<li>与数据平面中的代理通信，下发策略和配置</li>
<li>负责网络行为的可视化</li>
<li>通常提供 API 或者命令行工具可用于配置版本化管理，便于持续集成和部署</li>
</ul>
<p><strong>数据平面的特点</strong></p>
<ul>
<li>通常是按照无状态目标设计的，但实际上为了提高流量转发性能，需要缓存一些数据，因此无状态也是有争议的</li>
<li>直接处理入站和出站数据包，转发、路由、健康检查、负载均衡、认证、鉴权、产生监控数据等</li>
<li>对应用来说透明，即可以做到无感知部署</li>
</ul>
<h2 id="服务网格的实现模式"><a href="#服务网格的实现模式" class="headerlink" title="服务网格的实现模式"></a>服务网格的实现模式</h2><p>Service Mesh 架构示意图：<br><img src="https://img-blog.csdnimg.cn/20191116231047738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="Service Mesh架构示意图"></p>
<h2 id="Istio-架构解析"><a href="#Istio-架构解析" class="headerlink" title="Istio 架构解析"></a>Istio 架构解析</h2><p><img src="https://img-blog.csdnimg.cn/20191116231618741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Istio 是独立于平台的，可以在 Kubernetes 、 Consul 、虚拟机上部署的服务</li>
<li>Istio 的组成<ul>
<li>Envoy：智能代理、流量控制</li>
<li>Pilot：服务发现、流量管理</li>
<li>Mixer：访问控制、遥测</li>
<li>Citadel：终端用户认证、流量加密</li>
<li>Galley（1.1新增）：验证、处理和分配配置</li>
</ul>
</li>
<li>Service mesh 关注的方面<ul>
<li>可观察性</li>
<li>安全性</li>
<li>可运维性</li>
<li>可拓展性</li>
</ul>
</li>
<li>Istio 的策略执行组件可以扩展和定制，同时也是可拔插的</li>
<li>Istio 在数据平面为每个服务中注入一个 Envoy 代理以 Sidecar 形式运行来劫持所有进出服务的流量，同时对流量加以控制，通俗的讲就是应用程序你只管处理你的业务逻辑，其他的事情 Sidecar 会汇报给 Istio 控制平面处理</li>
<li>应用程序只需关注于业务逻辑（这才能生钱）即可，非功能性需求交给 Istio</li>
</ul>
<p><strong>设计目标</strong></p>
<ul>
<li>最大化透明度</li>
<li>可扩展性</li>
<li>可移植性</li>
<li>策略一致性</li>
</ul>
<h2 id="从边车模式到-Service-Mesh"><a href="#从边车模式到-Service-Mesh" class="headerlink" title="从边车模式到 Service Mesh"></a>从边车模式到 Service Mesh</h2><h3 id="什么是边车模式"><a href="#什么是边车模式" class="headerlink" title="什么是边车模式"></a>什么是边车模式</h3><blockquote>
<p>Deploy components of an application into a separate process or container to provide isolation and encapsulation.<br>— Sidecar pattern</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2019111623235962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="SideCar"></p>
<h3 id="边车模式设计"><a href="#边车模式设计" class="headerlink" title="边车模式设计"></a>边车模式设计</h3><p>有两种方法来实现边车模式：</p>
<ul>
<li>通过 SDK、Lib 等软件包的形式，在开发时引入该软件包依赖，使其与业务服务集成起来。</li>
<li>以 Sidecar 的形式，在运维的时候与应用服务集成在一起。</li>
</ul>
<h3 id="边车模式解决了什么问题"><a href="#边车模式解决了什么问题" class="headerlink" title="边车模式解决了什么问题"></a>边车模式解决了什么问题</h3><ul>
<li>控制与逻辑分离的问题<ul>
<li>业务代码只需要关心其复杂的业务逻辑</li>
<li>日志记录、监控、流量控制、服务注册、服务发现、服务限流、服务熔断、鉴权、访问控制等交给边车</li>
</ul>
</li>
<li>解决服务之间调用越来越复杂的问题<ul>
<li>随着分布式架构越来越复杂和微服务越拆越细，我们越来越迫切的希望有一个统一的控制面来管理我们的微服务，来帮助我们维护和管理所有微服务</li>
</ul>
</li>
</ul>
<h3 id="从边车模式到-Service-Mesh-1"><a href="#从边车模式到-Service-Mesh-1" class="headerlink" title="从边车模式到 Service Mesh"></a>从边车模式到 Service Mesh</h3><p>遵循边车模式进行实践从很早以前就开始了，开发人员一直试图将服务治理等通用功能提取成一个标准化的 Sidecar ，通过 Sidecar 代理来与其他系统进行交互，这样可以大大简化业务开发和运维。而随着分布式架构和微服务被越来越多的公司和开发者接受并使用，这一需求日益凸显。这就是 Service Mesh 服务网格诞生的契机，它是 CNCF（Cloud Native Computing Foundation，云原生基金会）目前主推的新一代微服务架构。</p>
<p>Service Mesh 将底层那些难以控制的网络通讯统一管理，诸如：流量管控，丢包重试，访问控制等。而上层的应用层协议只需关心业务逻辑即可。Service Mesh 是一个用于处理服务间通信的基础设施层，它负责为构建复杂的云原生应用传递可靠的网络请求。</p>
<h1 id="Kubernetes-vs-Service-Mesh"><a href="#Kubernetes-vs-Service-Mesh" class="headerlink" title="Kubernetes vs Service Mesh"></a>Kubernetes vs Service Mesh</h1><blockquote>
<p>Kubernetes 管理的对象是 Pod，Service Mesh 中管理的对象是 Service。</p>
</blockquote>
<ul>
<li>Kubernetes 的本质是应用的生命周期管理，具体来说就是部署和管理（扩缩容、自动恢复、发布）。</li>
<li>Kubernetes 为微服务提供了可扩展、高弹性的部署和管理平台。</li>
<li>Service Mesh 的基础是透明代理，通过 sidecar proxy 拦截到微服务间流量后再通过控制平面配置管理微服务的行为。</li>
<li>Service Mesh 将流量管理从 Kubernetes 中解耦，Service Mesh 内部的流量无需 kube-proxy 组件的支持，通过为更接近微服务应用层的抽象，管理服务间的流量、安全性和可观察性。</li>
<li>Service Mesh 是对 Kubernetes 中的 service 更上层的抽象，它的下一步是 serverless。</li>
</ul>
<hr>
<p>本文是针对ServiceMesher社区系列文章而整理的学习笔记，文章地址：<a href="https://www.servicemesher.com/istio-handbook/intro/service-mesh-the-microservices-in-post-kubernetes-era.html" target="_blank" rel="noopener">https://www.servicemesher.com/istio-handbook/intro/service-mesh-the-microservices-in-post-kubernetes-era.html</a></p>
]]></content>
      <categories>
        <category>Service Mesh</category>
      </categories>
      <tags>
        <tag>Service Mesh</tag>
        <tag>Istio</tag>
      </tags>
  </entry>
  <entry>
    <title>API网关概述</title>
    <url>/2020/01/27/Introduction-of-API-GateWay/</url>
    <content><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><ul>
<li>由于后端的微服务拆分，客户端通常需要请求多个服务获取所需数据。</li>
<li>不同客户端所需要的数据不一样。例如，PC需要的数据通常比移动端更加详细。</li>
<li>不同客户端网络环境差异大。例如，WAN vs LAN，移动网络 vs 非移动网络。</li>
<li>服务端实例的地址信息（IP + port）会动态更新。</li>
<li>微服务的拆分逻辑会变化，这种变化应该应该对客户端透明。</li>
<li>不同的服务可能采用不同的协议，有些协议是非web的。</li>
</ul>
<h1 id="2-什么是API网关？"><a href="#2-什么是API网关？" class="headerlink" title="2 什么是API网关？"></a>2 什么是API网关？</h1><p>API网关接收客户端的所有请求，并将请求路由到相应的后端服务，并提供接口聚合和协议转换。通常来说，API网关通过调用多个后端服务，并聚合结果的方式处理请求。它可将web协议转化为非web的内部后台协议。</p>
<a id="more"></a>

<p>核心功能：</p>
<ul>
<li>服务发现：</li>
<li>负载均衡：以某种算法分摊系统压力。</li>
<li>服务熔断：直接返回失败或者执行降价逻辑，防止雪崩。</li>
<li>流量控制：防止短时间内大量请求转发到后台压垮服务器。</li>
<li>认证鉴权：验证客户端的请求是否被授权。</li>
<li>灰度发布：</li>
</ul>
<p>其他功能：</p>
<ul>
<li>协议转换：web协议转非Web协议。</li>
<li>参数校验：对入参设置校验规则，由网关根据规则对无效请求进行过滤。</li>
<li>API管理：包括 API 的创建、测试、发布、下线、版本切换等。</li>
<li>监控告警：监控API请求次数、API调用延迟和API错误信息。</li>
<li>SDK生成：</li>
</ul>
<h1 id="3-实现方式"><a href="#3-实现方式" class="headerlink" title="3 实现方式"></a>3 实现方式</h1><p>将API网关作为客户端的唯一接入点。API网关主要有两种类型：</p>
<ul>
<li>one-size-fits-all网关</li>
<li>Backends for frontends网关</li>
</ul>
<h2 id="3-1-One-size-fits-all网关"><a href="#3-1-One-size-fits-all网关" class="headerlink" title="3.1 One-size-fits-all网关"></a>3.1 One-size-fits-all网关</h2><p>简单地将请求路由到相应服务。将请求扇出到多个后端服务。<br><img src="https://img-blog.csdnimg.cn/20191013124932708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="OSFA API Gateway"></p>
<h2 id="3-2-Backends-for-fronts网关"><a href="#3-2-Backends-for-fronts网关" class="headerlink" title="3.2 Backends for fronts网关"></a>3.2 Backends for fronts网关</h2><p>为每种客户端暴露不同的API。为每种客户端设计一个API网关，每个API网关为其客户端提供一种API。<br><img src="https://img-blog.csdnimg.cn/20191013125314703.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9jaHV4aW5nLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="Backends fro frontends API Gateway"></p>
<h1 id="4-优点"><a href="#4-优点" class="headerlink" title="4 优点"></a>4 优点</h1><ul>
<li>使后端的微服务拆分对客户端透明。</li>
<li>客户端无需关心后端服务的实例地址（IP + port）。</li>
<li>可为每个客户端提供最优API。</li>
<li>减少请求次数。</li>
<li>简化客户端的逻辑（由调用多个后台服务变为只调用API网关）。</li>
<li>可将标准的Web API协议转化为任意的后端协议。</li>
</ul>
<h1 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5 缺点"></a>5 缺点</h1><ul>
<li>增加复杂性。增加了API网关模块，带来了额外的开发、部署、管理成本。</li>
<li>增加响应时间。调用链路多了一跳（API网关）。</li>
</ul>
<p><strong>Issues:</strong></p>
<blockquote>
<p>How implement the API gateway?<br>event-driven/reactive approach is the best if it must scale to handle high loads.</p>
</blockquote>
<p>参考来源：<br>[1] <a href="https://microservices.io/patterns/apigateway.html" target="_blank" rel="noopener">https://microservices.io/patterns/apigateway.html</a><br>[2] <a href="https://www.nginx.com/learn/api-gateway/" target="_blank" rel="noopener">https://www.nginx.com/learn/api-gateway/</a><br>[3] <a href="https://aws.amazon.com/cn/api-gateway/features/" target="_blank" rel="noopener">https://aws.amazon.com/cn/api-gateway/features/</a><br>[4] <a href="https://cloud.tencent.com/document/product/628/11755" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/628/11755</a></p>
]]></content>
      <categories>
        <category>后台开发</category>
      </categories>
      <tags>
        <tag>API网关</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过GitHub+Hexo搭建博客</title>
    <url>/2020/01/27/How-to-create-a-hexo-blog/</url>
    <content><![CDATA[<h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ brew install <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> -g hexo</span><br></pre></td></tr></table></figure>

<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo init</span><br></pre></td></tr></table></figure>

<h2 id="生成网页文件和开启服务器"><a href="#生成网页文件和开启服务器" class="headerlink" title="生成网页文件和开启服务器"></a>生成网页文件和开启服务器</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo g</span><br><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><ol>
<li><p>修改<code>_config.yml</code>，修改deploy为：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'git'</span></span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/xzygis/xzygis.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成静态文件并上传Github</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo g</span><br><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>若执行<code>hexo d</code>出错则执行<code>npm install hexo-deployer-git --save</code>。</p>
<p>执行<code>hexo d</code>会提示输入用户名密码。</p>
<h2 id="配置next主题"><a href="#配置next主题" class="headerlink" title="配置next主题"></a>配置next主题</h2><p>在blog目录下执行</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone --branch v5.<span class="number">1.4</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<p>修改<code>_config.yml</code>，设置theme为next。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
